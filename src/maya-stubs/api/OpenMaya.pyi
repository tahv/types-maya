from typing import Any, Callable, ClassVar, Iterable, Literal, Sequence, SupportsIndex

from _typeshed import Incomplete
from typing_extensions import Annotated, Self, TypeAlias, overload

__all__ = [
    "MURI",
    "MAngle",
    "MArgDatabase",
    "MArgList",
    "MArgParser",
    "MArrayDataHandle",
    "MAttributeIndex",
    "MAttributePattern",
    "MAttributeSpec",
    "MAttributeSpecArray",
    "MBoundingBox",
    "MCacheSchema",
    "MCallbackId",
    "MCallbackIdArray",
    "MCameraMessage",
    "MColor",
    "MColorArray",
    "MCommandMessage",
    "MConditionMessage",
    "MContainerMessage",
    "MDAGDrawOverrideInfo",
    "MDGContext",
    "MDGMessage",
    "MDGModifier",
    "MDagMessage",
    "MDagModifier",
    "MDagPath",
    "MDagPathArray",
    "MDataBlock",
    "MDataHandle",
    "MDistance",
    "MDoubleArray",
    "MEulerRotation",
    "MEvaluationNode",
    "MEvaluationNodeIterator",
    "MEventMessage",
    "MExternalContentInfoTable",
    "MExternalContentLocationTable",
    "MFileObject",
    "MFloatArray",
    "MFloatMatrix",
    "MFloatPoint",
    "MFloatPointArray",
    "MFloatVector",
    "MFloatVectorArray",
    "MFn",
    "MFnAssembly",
    "MFnAttribute",
    "MFnBase",
    "MFnCamera",
    "MFnComponent",
    "MFnComponentListData",
    "MFnCompoundAttribute",
    "MFnContainerNode",
    "MFnDagNode",
    "MFnData",
    "MFnDependencyNode",
    "MFnDisplayLayer",
    "MFnDisplayLayerManager",
    "MFnDoubleArrayData",
    "MFnDoubleIndexedComponent",
    "MFnEnumAttribute",
    "MFnGenericAttribute",
    "MFnGeometryData",
    "MFnIntArrayData",
    "MFnLightDataAttribute",
    "MFnMatrixArrayData",
    "MFnMatrixAttribute",
    "MFnMatrixData",
    "MFnMesh",
    "MFnMeshData",
    "MFnMessageAttribute",
    "MFnNumericAttribute",
    "MFnNumericData",
    "MFnNurbsCurve",
    "MFnNurbsCurveData",
    "MFnNurbsSurface",
    "MFnNurbsSurfaceData",
    "MFnPlugin",
    "MFnPluginData",
    "MFnPointArrayData",
    "MFnReference",
    "MFnSet",
    "MFnSingleIndexedComponent",
    "MFnStringArrayData",
    "MFnStringData",
    "MFnTransform",
    "MFnTripleIndexedComponent",
    "MFnTypedAttribute",
    "MFnUInt64ArrayData",
    "MFnUnitAttribute",
    "MFnVectorArrayData",
    "MGlobal",
    "MImage",
    "MInt64Array",
    "MIntArray",
    "MItCurveCV",
    "MItDag",
    "MItDependencyGraph",
    "MItDependencyNodes",
    "MItGeometry",
    "MItMeshEdge",
    "MItMeshFaceVertex",
    "MItMeshPolygon",
    "MItMeshVertex",
    "MItSelectionList",
    "MItSurfaceCV",
    "MIteratorType",
    "MLockMessage",
    "MMatrix",
    "MMatrixArray",
    "MMeshIntersector",
    "MMeshIsectAccelParams",
    "MMeshSmoothOptions",
    "MMessage",
    "MModelMessage",
    "MNamespace",
    "MNodeCacheDisablingInfo",
    "MNodeCacheSetupInfo",
    "MNodeClass",
    "MNodeMessage",
    "MObject",
    "MObjectArray",
    "MObjectHandle",
    "MObjectSetMessage",
    "MPlane",
    "MPlug",
    "MPlugArray",
    "MPoint",
    "MPointArray",
    "MPointOnMesh",
    "MPolyMessage",
    "MPxAttributePatternFactory",
    "MPxCommand",
    "MPxData",
    "MPxGeometryData",
    "MPxGeometryIterator",
    "MPxNode",
    "MPxSurfaceShape",
    "MQuaternion",
    "MRampAttribute",
    "MRichSelection",
    "MSceneMessage",
    "MSelectionList",
    "MSelectionMask",
    "MSpace",
    "MSyntax",
    "MTime",
    "MTimeArray",
    "MTimeRange",
    "MTimerMessage",
    "MTransformationMatrix",
    "MTypeId",
    "MUint64Array",
    "MUintArray",
    "MUserData",
    "MUserEventMessage",
    "MUuid",
    "MVector",
    "MVectorArray",
    "MWeight",
]

MCallbackId: Incomplete
MCameraMessage: Incomplete
MCommandMessage: Incomplete
MConditionMessage: Incomplete
MContainerMessage: Incomplete
MDAGDrawOverrideInfo: Incomplete
MDagMessage: Incomplete
MDataBlock: Incomplete
MDataHandle: Incomplete
MDGMessage: Incomplete
MEulerRotation: Incomplete
MEvaluationNode: Incomplete
MEvaluationNodeIterator: Incomplete
MEventMessage: Incomplete
MExternalContentInfoTable: Incomplete
MExternalContentLocationTable: Incomplete
MFileObject: Incomplete
MFloatPoint: Incomplete
MFloatVector: Incomplete
MFnAssembly: Incomplete
MFnCamera: Incomplete
MFnComponent: Incomplete
MFnComponentListData: Incomplete
MFnContainerNode: Incomplete
MFnDisplayLayer: Incomplete
MFnDisplayLayerManager: Incomplete
MFnDoubleArrayData: Incomplete
MFnDoubleIndexedComponent: Incomplete
MFnGeometryData: Incomplete
MFnIntArrayData: Incomplete
MFnMatrixArrayData: Incomplete
MFnMatrixData: Incomplete
MFnMesh: Incomplete
MFnMeshData: Incomplete
MFnNurbsCurve: Incomplete
MFnNurbsCurveData: Incomplete
MFnNurbsSurface: Incomplete
MFnNurbsSurfaceData: Incomplete
MFnPlugin: Incomplete
MFnPluginData: Incomplete
MFnPointArrayData: Incomplete
MFnReference: Incomplete
MFnSet: Incomplete
MFnSingleIndexedComponent: Incomplete
MFnStringArrayData: Incomplete
MFnStringData: Incomplete
MFnTransform: Incomplete
MFnTripleIndexedComponent: Incomplete
MFnUInt64ArrayData: Incomplete
MFnVectorArrayData: Incomplete
MGlobal: Incomplete
MImage: Incomplete
MItCurveCV: Incomplete
MItDag: Incomplete
MItDependencyGraph: Incomplete
MItDependencyNodes: Incomplete
MIteratorType: Incomplete
MItGeometry: Incomplete
MItMeshEdge: Incomplete
MItMeshFaceVertex: Incomplete
MItMeshPolygon: Incomplete
MItMeshVertex: Incomplete
MItSelectionList: Incomplete
MItSurfaceCV: Incomplete
MLockMessage: Incomplete
MMeshIntersector: Incomplete
MMeshIsectAccelParams: Incomplete
MMeshSmoothOptions: Incomplete
MMessage: Incomplete
MModelMessage: Incomplete
MNamespace: Incomplete
MNodeCacheDisablingInfo: Incomplete
MNodeCacheSetupInfo: Incomplete
MNodeClass: Incomplete
MNodeMessage: Incomplete
MObjectHandle: Incomplete
MObjectSetMessage: Incomplete
MPlane: Incomplete
MPoint: Incomplete
MPointOnMesh: Incomplete
MPolyMessage: Incomplete
MPxAttributePatternFactory: Incomplete
MPxCommand: Incomplete
MPxData: Incomplete
MPxGeometryData: Incomplete
MPxGeometryIterator: Incomplete
MPxNode: Incomplete
MPxSurfaceShape: Incomplete
MRampAttribute: Incomplete
MRichSelection: Incomplete
MSceneMessage: Incomplete
MSelectionMask: Incomplete
MTimeRange: Incomplete
MTimerMessage: Incomplete
MURI: Incomplete
MUserData: Incomplete
MUserEventMessage: Incomplete
MUuid: Incomplete
MWeight: Incomplete

_MFnType: TypeAlias = int

class MFnBase:
    @overload
    def hasObj(self, type: _MFnType, /) -> bool: ...
    @overload
    def hasObj(self, object: MObject, /) -> bool: ...
    def object(self) -> MObject: ...
    def setObject(self, object: MObject, /) -> Self: ...
    def type(self) -> _MFnType: ...

class MObject:
    kNullObj: ClassVar[MObject]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MObject, /) -> None: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def apiType(self) -> _MFnType: ...
    def hasFn(self, fn: _MFnType, /) -> bool: ...
    def isNull(self) -> bool: ...
    @property
    def apiTypeStr(self) -> str: ...

class MTypeId:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MTypeId, /) -> None: ...
    @overload
    def __init__(self, id: int, /) -> None: ...
    @overload
    def __init__(self, prefix: int, id: int, /) -> None: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def id(self) -> int: ...

class MArgDatabase(MArgParser):
    def __init__(self, syntax: MSyntax, args: MArgList, /) -> None: ...
    def commandArgumentMSelectionList(self, index: int, /) -> MSelectionList: ...
    def flagArgumentMSelectionList(
        self, flag: str, index: int, /
    ) -> MSelectionList: ...
    def getObjectList(self) -> MSelectionList: ...

class MArgList:
    kInvalidArgIndex: Literal[-1]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MArgList, /) -> None: ...
    def __len__(self) -> int: ...
    def addArg(
        self,
        value: bool | float | str | MAngle | MDistance | MPoint | MTime | MVector,
        /,
    ) -> Self: ...
    def asAngle(self, index: int, /) -> MAngle: ...
    def asBool(self, index: int, /) -> bool: ...
    def asDistance(self, index: int, /) -> MDistance: ...
    def asDouble(self, index: int, /) -> float: ...
    def asDoubleArray(self, index: int, /) -> MDoubleArray: ...
    def asFloat(self, index: int, /) -> float: ...
    def asInt(self, index: int, /) -> int: ...
    def asIntArray(self, index: int, /) -> MIntArray: ...
    def asMatrix(self, index: int, /) -> MMatrix: ...
    def asPoint(self, index: int, /, numElements: int = 3) -> MPoint: ...
    def asString(self, index: int, /) -> str: ...
    def asStringArray(self, index: int, /) -> str: ...
    def asTime(self, index: int, /) -> MTime: ...
    def asVector(self, index: int, /) -> MVector: ...
    def flagIndex(self, shortName: str, /, longName: str | None = None) -> int: ...
    def lastArgUsed(self) -> int: ...

class MArgParser:
    def __init__(self, syntax: MSyntax, args: MArgList, /) -> None: ...
    def commandArgumentBool(self, index: int, /) -> bool: ...
    def commandArgumentDouble(self, index: int, /) -> float: ...
    def commandArgumentFloat(self, index: int, /) -> float: ...
    def commandArgumentInt(self, index: int, /) -> int: ...
    def commandArgumentMAngle(self, index: int, /) -> MAngle: ...
    def commandArgumentMDistance(self, index: int, /) -> MDistance: ...
    def commandArgumentMTime(self, index: int, /) -> MTime: ...
    def commandArgumentString(self, index: int, /) -> str: ...
    def flagArgumentBool(self, flag: str, index: int, /) -> bool: ...
    def flagArgumentDouble(self, flag: str, index: int, /) -> float: ...
    def flagArgumentFloat(self, flag: str, index: int, /) -> float: ...
    def flagArgumentInt(self, flag: str, index: int, /) -> int: ...
    def flagArgumentMAngle(self, flag: str, index: int, /) -> MAngle: ...
    def flagArgumentMDistance(self, flag: str, index: int, /) -> MDistance: ...
    def flagArgumentMTime(self, flag: str, index: int, /) -> MTime: ...
    def flagArgumentString(self, flag: str, index: int, /) -> str: ...
    def getFlagArgumentList(self, flag: str, occurrence: int, /) -> MArgList: ...
    def getFlagArgumentPosition(self, flag: str, index: int, /) -> int: ...
    def getObjectStrings(self) -> tuple[str, ...]: ...
    def isFlagSet(self, flag: str) -> bool: ...
    def numberOfFlagUses(self, flag: str) -> int: ...
    @property
    def isEdit(self) -> bool: ...
    @property
    def isQuery(self) -> bool: ...
    @property
    def numberOfFlagsUsed(self) -> int: ...

class MArrayDataBuilder:
    def __len__(self) -> int: ...
    def addElement(self, index: int, /) -> MDataHandle: ...
    def addElementArray(self, index: int, /) -> MArrayDataHandle: ...
    def addLast(self) -> MDataHandle: ...
    def addLastArray(self) -> MArrayDataHandle: ...
    def copy(self, source: MArrayDataBuilder, /) -> Self: ...
    def growArray(self, amount: int, /) -> Self: ...
    def removeElement(self, index: int, /) -> Self: ...
    def setGrowSize(self, size: int, /) -> Self: ...

class MArrayDataHandle:
    def __len__(self) -> int: ...
    def builder(self) -> MArrayDataBuilder: ...
    def copy(self, source: MArrayDataHandle, /) -> Self: ...
    def elementLogicalIndex(self) -> int: ...
    def inputArrayValue(self) -> MArrayDataHandle: ...
    def inputValue(self) -> MDataHandle: ...
    def isDone(self) -> bool: ...
    def jumpToLogicalElement(self, index: int, /) -> Self: ...
    def jumpToPhysicalElement(self, position: int, /) -> Self: ...
    def next(self) -> bool: ...
    def outputArrayValue(self) -> MArrayDataHandle: ...
    def outputValue(self) -> MDataHandle: ...
    def set(self, builder: MArrayDataBuilder) -> Self: ...
    def setAllClean(self) -> Self: ...
    def setClean(self) -> Self: ...

class MAttributeIndex:
    MIndexType: TypeAlias = Literal[0, 1]
    kInteger: Literal[0]
    kFloat: Literal[1]
    def __eq__(self, value: object, /) -> bool: ...
    def __ge__(self, value: object, /) -> bool: ...
    def __gt__(self, value: object, /) -> bool: ...
    def __le__(self, value: object, /) -> bool: ...
    def __lt__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def copy(self, source: MAttributeIndex, /) -> Self: ...
    def getLower(self) -> int | float: ...
    def getUpper(self) -> int | float: ...
    def getValue(self) -> int | float: ...
    def hasLowerBound(self) -> bool: ...
    def hasRange(self) -> bool: ...
    def hasUpperBound(self) -> bool: ...
    def hasValidRange(self) -> bool: ...
    def isBounded(self) -> bool: ...
    def setLower(self, value: int | float, /) -> Self: ...
    def setType(self, type: MIndexType) -> Self: ...
    def setUpper(self, value: int | float, /) -> Self: ...
    def setValue(self, value: int | float, /) -> Self: ...
    def type(self) -> MIndexType: ...

class MAttributePattern:
    def __init__(self, name: str, /) -> None: ...
    def addRootAttr(self, attr: MObject) -> None: ...
    def name(self) -> str: ...
    @overload
    def removeRootAttr(self, idx: int, /) -> None: ...
    @overload
    def removeRootAttr(self, attr: MObject, /) -> None: ...
    def rootAttr(self, idx: int, /) -> MObject: ...
    def rootAttrCount(self) -> int: ...
    @classmethod
    def attrPattern(cls, n: int, /) -> Self: ...
    @classmethod
    def attrPatternCount(cls) -> int: ...
    @classmethod
    def findPattern(cls, name: str, /) -> Self: ...

class MAttributeSpec:
    @overload
    def __init__(self, name: str, /) -> None: ...
    @overload
    def __init__(self, other: MAttributeSpec, /) -> None: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __ge__(self, value: MAttributeSpec, /) -> bool: ...
    def __getitem__(self, index: int, /) -> MAttributeIndex: ...
    def __gt__(self, value: MAttributeSpec, /) -> bool: ...
    def __le__(self, value: MAttributeSpec, /) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, value: MAttributeSpec, /) -> bool: ...
    def copy(self, source: MAttributeSpec) -> Self: ...
    @property
    def dimensions(self) -> int: ...
    @dimensions.setter
    def dimensions(self, value: int) -> None: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...

class MAttributeSpecArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MAttributeSpecArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MAttributeSpec, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MAttributeSpec], /) -> None: ...
    def __add__(self, value: list[MAttributeSpec], /) -> MAttributeSpecArray: ...
    def __contains__(self, key: MAttributeSpec, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MAttributeSpec: ...
    def __iadd__(self, value: Iterable[MAttributeSpec], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MAttributeSpecArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MAttributeSpecArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MAttributeSpec],
        /,
    ) -> None: ...
    def append(self, value: MAttributeSpec, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MAttributeSpecArray | Sequence[MAttributeSpec], /) -> None: ...
    def insert(self, value: MAttributeSpec, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MBoundingBox:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MBoundingBox, /) -> None: ...
    @overload
    def __init__(self, min: MPoint, max: MPoint, /) -> None: ...
    def clear(self) -> Self: ...
    def contains(self, point: MPoint, /) -> bool: ...
    @overload
    def expand(self, point: MPoint, /) -> Self: ...
    @overload
    def expand(self, box: MBoundingBox, /) -> Self: ...
    def intersects(self, box: MBoundingBox, tolerance: float, /) -> bool: ...
    def transformUsing(self, matrix: MMatrix, /) -> Self: ...
    @property
    def center(self) -> MPoint: ...
    @property
    def depth(self) -> float: ...
    @property
    def height(self) -> float: ...
    @property
    def max(self) -> MPoint: ...
    @property
    def min(self) -> MPoint: ...
    @property
    def width(self) -> float: ...

class MCacheSchema:
    def __init__(self) -> None: ...
    def add(self, attribute: MObject, /) -> Self: ...
    def reset(self) -> None: ...

class MDagPath:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MDagPath, /) -> None: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def apiType(self) -> int: ...  # NOTE: MFn constant
    def child(self, childNum: int, /) -> MObject: ...
    def childCount(self) -> int: ...
    def exclusiveMatrix(self) -> MMatrix: ...
    def exclusiveMatrixInverse(self) -> MMatrix: ...
    def extendToShape(self, shapeNum: int = 0) -> Self: ...
    def fullPathName(self) -> str: ...
    def getAllPathsTo(self, node: MObject, /) -> MDagPathArray: ...
    def getAPathTo(self, node: MObject, /) -> MDagPath: ...
    def getDisplayStatus(self) -> int: ...  # TODO: int ?
    def getDrawOverrideInfo(self) -> MDAGDrawOverrideInfo: ...
    def getPath(self, pathNum: int = 0) -> MDagPath: ...
    def hasFn(self, type: int, /) -> bool: ...
    def inclusiveMatrix(self) -> MMatrix: ...
    def inclusiveMatrixInverse(self) -> MMatrix: ...
    def instanceNumber(self) -> int: ...
    def isInstanced(self) -> bool: ...
    def isTemplated(self) -> bool: ...
    def isValid(self) -> bool: ...
    def isVisible(self) -> bool: ...
    def length(self) -> int: ...
    def matchTransform(self, source: MDagPath) -> MTransformationMatrix: ...
    def node(self) -> MObject: ...
    def numberOfShapesDirectlyBelow(self) -> int: ...
    def partialPathName(self) -> str: ...
    def pathCount(self) -> int: ...
    def pop(self, num: int = 1) -> Self: ...
    def push(self, child: MObject, /) -> Self: ...
    def set(self, path: MDagPath, /) -> Self: ...
    def transform(self) -> MObject: ...

class MColor:
    DataType: TypeAlias = Literal[0, 1, 2]
    kFloat: Literal[0]
    kByte: Literal[1]
    kShort: Literal[2]
    MColorType: TypeAlias = Literal[0, 1, 2, 3]
    kRGB: Literal[0]
    kHSV: Literal[1]
    kCMY: Literal[2]
    kCMYK: Literal[3]
    kOpaqueBlack: ClassVar[MColor]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MColor, /) -> None: ...
    @overload
    def __init__(
        self,
        components: Sequence[float],
        /,
        model: MColorType = kRGB,
        dataType: DataType = kFloat,
    ) -> None: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __getitem__(self, index: int, /) -> float: ...
    def __setitem__(self, index: int, value: float, /) -> None: ...
    def __add__(self, value: MColor, /) -> MColor: ...
    def __radd__(self, value: MColor, /) -> MColor: ...
    def __iadd__(self, value: MColor, /) -> Self: ...
    def __len__(self) -> Literal[4]: ...
    def __mul__(self, value: MColor | float, /) -> MColor: ...
    def __rmul__(self, value: MColor | float, /) -> MColor: ...
    def __imul__(self, value: MColor | float, /) -> Self: ...
    def __truediv__(self, value: float, /) -> MColor: ...
    def __rtruediv__(self, value: float, /) -> MColor: ...
    def __itruediv__(self, value: float, /) -> Self: ...
    def getColor(self, model: MColorType = kRGB) -> list[float]: ...
    def setColor(
        self,
        components: Sequence[float],
        /,
        model: MColorType = kRGB,
        dataType: DataType = kFloat,
    ) -> Self: ...
    @property
    def a(self) -> float: ...
    @a.setter
    def a(self, value: float) -> None: ...
    @property
    def r(self) -> float: ...
    @r.setter
    def r(self, value: float) -> None: ...
    @property
    def g(self) -> float: ...
    @g.setter
    def g(self, value: float) -> None: ...
    @property
    def b(self) -> float: ...
    @b.setter
    def b(self, value: float) -> None: ...

class MFnAttribute(MFnBase):
    DisconnectBehavior: TypeAlias = Literal[0, 1, 2]
    kDelete: Literal[0]
    kReset: Literal[1]
    kNothing: Literal[2]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    def accepts(self, type: MTypeId | _MFnType, /) -> bool: ...
    def acceptsAttribute(self, attr: MFnAttribute, /) -> bool: ...
    def addToCategory(self, category: str, /) -> bool: ...
    def getAddAttrCmd(self, longFlags: bool) -> str: ...
    def hasCategory(self, category: str, /) -> str: ...
    def pathName(self) -> str: ...
    def setNiceNameOverride(self, localizedName: str, /) -> None: ...
    @property
    def affectsAppearance(self) -> bool: ...
    @affectsAppearance.setter
    def affectsAppearance(self, value: bool) -> None: ...
    @property
    def affectsWorldSpace(self) -> bool: ...
    @affectsWorldSpace.setter
    def affectsWorldSpace(self, value: bool) -> None: ...
    @property
    def array(self) -> bool: ...
    @array.setter
    def array(self, value: bool) -> None: ...
    @property
    def cached(self) -> bool: ...
    @cached.setter
    def cached(self, value: bool) -> None: ...
    @property
    def channelBox(self) -> bool: ...
    @channelBox.setter
    def channelBox(self, value: bool) -> None: ...
    @property
    def connectable(self) -> bool: ...
    @connectable.setter
    def connectable(self, value: bool) -> None: ...
    @property
    def disconnectBehavior(self) -> DisconnectBehavior: ...
    @disconnectBehavior.setter
    def disconnectBehavior(self, value: DisconnectBehavior) -> None: ...
    @property
    def dynamic(self) -> bool: ...
    @property
    def enforcingUniqueName(self) -> bool: ...
    @property
    def extension(self) -> bool: ...
    @property
    def hidden(self) -> bool: ...
    @hidden.setter
    def hidden(self, value: bool) -> None: ...
    @property
    def indeterminant(self) -> bool: ...
    @indeterminant.setter
    def indeterminant(self, value: bool) -> None: ...
    @property
    def indexMatters(self) -> bool: ...
    @indexMatters.setter
    def indexMatters(self, value: bool) -> None: ...
    @property
    def internal(self) -> bool: ...
    @internal.setter
    def internal(self, value: bool) -> None: ...
    @property
    def isProxyAttribute(self) -> bool: ...
    @property
    def keyable(self) -> bool: ...
    @keyable.setter
    def keyable(self, value: bool) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def parent(self) -> bool: ...
    @parent.setter
    def parent(self, value: MObject) -> None: ...
    @property
    def readable(self) -> bool: ...
    @readable.setter
    def readable(self, value: bool) -> None: ...
    @property
    def renderSource(self) -> bool: ...
    @renderSource.setter
    def renderSource(self, value: bool) -> None: ...
    @property
    def shortName(self) -> str: ...
    @property
    def storable(self) -> bool: ...
    @storable.setter
    def storable(self, value: bool) -> None: ...
    @property
    def usedAsColor(self) -> bool: ...
    @usedAsColor.setter
    def usedAsColor(self, value: bool) -> None: ...
    @property
    def usedAsFilename(self) -> bool: ...
    @usedAsFilename.setter
    def usedAsFilename(self, value: bool) -> None: ...
    @property
    def usesArrayDataBuilder(self) -> bool: ...
    @usesArrayDataBuilder.setter
    def usesArrayDataBuilder(self, value: bool) -> None: ...
    @property
    def worldSpace(self) -> bool: ...
    @worldSpace.setter
    def worldSpace(self, value: bool) -> None: ...
    @property
    def writable(self) -> bool: ...
    @writable.setter
    def writable(self, value: bool) -> None: ...

class MFnData:
    Type: TypeAlias = Literal[
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
        21, 22, 23, 24, 25, 26,
    ]  # fmt: off
    kInvalid: Literal[0]
    kNumeric: Literal[1]
    kPlugin: Literal[2]
    kPluginGeometry: Literal[3]
    kString: Literal[4]
    kMatrix: Literal[5]
    kStringArray: Literal[6]
    kDoubleArray: Literal[7]
    kFloatArray: Literal[8]
    kIntArray: Literal[9]
    kPointArray: Literal[10]
    kVectorArray: Literal[11]
    kMatrixArray: Literal[12]
    kComponentList: Literal[13]
    kMesh: Literal[14]
    kLattice: Literal[15]
    kNurbsCurve: Literal[16]
    kNurbsSurface: Literal[17]
    kSphere: Literal[18]
    kDynArrayAttrs: Literal[19]
    kDynSweptGeometry: Literal[20]
    kSubdSurface: Literal[21]
    kNObject: Literal[22]
    kNId: Literal[23]
    kAny: Literal[24]
    kFalloffFunction: Literal[25]
    kLast: Literal[26]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...

class MFnNumericData(MFnData):
    Type: TypeAlias = Literal[
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
    ]
    kInvalid: Literal[0]
    kBoolean: Literal[1]
    kByte: Literal[2]
    kChar: Literal[3]
    kShort: Literal[4]
    k2Short: Literal[5]
    k3Short: Literal[6]
    kInt: Literal[7]
    kLong: Literal[7]
    k2Int: Literal[8]
    k2Long: Literal[8]
    k3Int: Literal[9]
    k3Long: Literal[9]
    kInt64: Literal[10]
    kFloat: Literal[11]
    k2Float: Literal[12]
    k3Float: Literal[13]
    kDouble: Literal[14]
    k2Double: Literal[15]
    k3Double: Literal[16]
    k4Double: Literal[17]
    kAddr: Literal[18]
    kLast: Literal[19]  # type: ignore[assignment] # pyright: ignore[reportIncompatibleVariableOverride]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    def create(self, type: Type, /) -> MObject: ...
    def getData(self) -> list[float]: ...
    def numericType(self) -> int: ...
    def setData(self, seq: list[float], /) -> Self: ...

class MSelectionList:
    MergeStrategy: TypeAlias = Literal[0, 1, 2]
    kMergeNormal: Literal[0]
    kXORWithList: Literal[1]
    kRemoveFromList: Literal[2]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MSelectionList, /) -> None: ...
    @overload
    def add(self, pattern: str, /, searchChildNamespaces: bool = False) -> Self: ...
    @overload
    def add(
        self,
        item: MObject | MDagPath | MPlug | tuple[MDagPath, MObject],
        /,
        mergeWithExisting: bool = True,
    ) -> Self: ...
    def clear(self) -> Self: ...
    def copy(self, src: MSelectionList, /) -> Self: ...
    def getComponent(self, index: int, /) -> tuple[MDagPath, MObject]: ...
    def getDagPath(self, index: int, /) -> MDagPath: ...
    def getDependNode(self, index: int, /) -> MObject: ...
    def getPlug(self, index: int, /) -> MPlug: ...
    def getSelectionStrings(self, index: int, /) -> tuple[str, ...]: ...
    def hasItem(
        self, item: MObject | MDagPath | MPlug | tuple[MDagPath, MObject], /
    ) -> bool: ...
    def hasItemPartly(self, dagPath: MDagPath, component: MObject, /) -> bool: ...
    def intersect(
        self, other: MSelectionList, /, expandToLeaves: bool = False
    ) -> Self: ...
    def isEmpty(self) -> bool: ...
    def length(self) -> int: ...
    def merge(self, other: MSelectionList, /, strategy: MergeStrategy) -> Self: ...
    def remove(self, index: int, /) -> Self: ...
    def replace(
        self,
        index: int,
        newItem: MObject | MDagPath | MPlug | tuple[MDagPath, MObject],
        /,
    ) -> Self: ...
    def toggle(self, dagPath: MDagPath, component: MObject, /) -> Self: ...

class MMatrix:
    kTolerance: float = 1e-10
    kIdentity: MMatrix
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MMatrix, /) -> None: ...
    @overload
    def __init__(self, values: Annotated[Iterable[float], "[16]"], /) -> None: ...
    @overload
    def __init__(
        self, values: Annotated[Sequence[Sequence[float]], "[4[4]]"], /
    ) -> None: ...
    def __add__(self, value: MMatrix, /) -> MMatrix: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __getitem__(self, key: int, /) -> float: ...
    def __iadd__(self, value: MMatrix, /) -> Self: ...
    def __imul__(self, value: MMatrix | float, /) -> Self: ...
    def __isub__(self, value: MMatrix, /) -> Self: ...
    def __len__(self) -> Literal[16]: ...
    def __mul__(self, value: MMatrix | float, /) -> MMatrix: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __rmul__(self, value: MMatrix | float, /) -> MMatrix: ...
    def __setitem__(self, key: int, value: float, /) -> None: ...
    def __sub__(self, value: MMatrix, /) -> MMatrix: ...
    def adjoint(self) -> MMatrix: ...
    def det3x3(self) -> float: ...
    def det4x4(self) -> float: ...
    def getElement(self, row: int, col: int, /) -> float: ...
    def homogenize(self) -> MMatrix: ...
    def inverse(self) -> MMatrix: ...
    def isEquivalent(
        self, other: MMatrix, /, tolerance: float = kTolerance
    ) -> bool: ...
    def isSingular(self) -> bool: ...
    def setElement(self, row: int, col: int, value: float, /) -> Self: ...
    def setToIdentity(self) -> Self: ...
    def setToProduct(self, left: MMatrix, right: MMatrix, /) -> Self: ...
    def transpose(self) -> MMatrix: ...

class MFloatMatrix:
    kTolerance: Annotated[float, "9.9999997473787e-06"] = ...
    kIdentity: MMatrix
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MFloatMatrix, /) -> None: ...
    @overload
    def __init__(self, values: Annotated[Iterable[float], "[16]"], /) -> None: ...
    @overload
    def __init__(
        self, values: Annotated[Sequence[Sequence[float]], "[4[4]]"], /
    ) -> None: ...
    def __add__(self, value: MFloatMatrix, /) -> MFloatMatrix: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __getitem__(self, key: int, /) -> float: ...
    def __iadd__(self, value: MFloatMatrix, /) -> Self: ...
    def __imul__(self, value: MFloatMatrix | float, /) -> Self: ...
    def __isub__(self, value: MFloatMatrix, /) -> Self: ...
    def __len__(self) -> Literal[16]: ...
    def __mul__(self, value: MFloatMatrix | float, /) -> MFloatMatrix: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __rmul__(self, value: MFloatMatrix | float, /) -> MFloatMatrix: ...
    def __setitem__(self, key: int, value: float, /) -> None: ...
    def __sub__(self, value: MFloatMatrix, /) -> MFloatMatrix: ...
    def adjoint(self) -> MFloatMatrix: ...
    def det3x3(self) -> float: ...
    def det4x4(self) -> float: ...
    def getElement(self, row: int, col: int, /) -> float: ...
    def homogenize(self) -> MFloatMatrix: ...
    def inverse(self) -> MFloatMatrix: ...
    def isEquivalent(
        self, other: MFloatMatrix, /, tolerance: float = kTolerance
    ) -> bool: ...
    def setElement(self, row: int, col: int, value: float, /) -> Self: ...
    def setToIdentity(self) -> Self: ...
    def setToProduct(self, left: MFloatMatrix, right: MFloatMatrix, /) -> Self: ...
    def transpose(self) -> MFloatMatrix: ...

class MTransformationMatrix:
    kTolerance: float = 1e-10
    kIdentity: MTransformationMatrix
    RotationOrder: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7]
    kInvalid: Literal[0]
    kXYZ: Literal[1]
    kYZX: Literal[2]
    kZXY: Literal[3]
    kXZY: Literal[4]
    kYXZ: Literal[5]
    kZYX: Literal[6]
    kLast: Literal[7]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MTransformationMatrix | MMatrix, /) -> None: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def asMatrix(self, interp: float = 1.0) -> MMatrix: ...
    def asMatrixInverse(self) -> MMatrix: ...
    def asRotateMatrix(self) -> MMatrix: ...
    def asScaleMatrix(self) -> MMatrix: ...
    def isEquivalent(
        self, other: MTransformationMatrix, /, tolerance: float = kTolerance
    ) -> bool: ...
    def reorderRotation(self, order: RotationOrder, /) -> Self: ...
    def rotateBy(
        self, rot: MQuaternion | MEulerRotation, space: MSpace.Space, /
    ) -> Self: ...
    def rotateByComponents(
        self, seq: Sequence[float], space: MSpace.Space, asQuaternion: bool = False, /
    ) -> Self: ...
    def rotatePivot(self, space: MSpace.Space, /) -> MPoint: ...
    def rotatePivotTranslation(self, space: MSpace.Space, /) -> MVector: ...
    @overload
    def rotation(self, asQuaternion: Literal[False] = False) -> MEulerRotation: ...
    @overload
    def rotation(self, asQuaternion: Literal[True]) -> MQuaternion: ...
    @overload
    def rotationComponents(
        self, asQuaternion: Literal[False] = False
    ) -> Annotated[list[int], "[x, y, z, RotationOrder]"]: ...
    @overload
    def rotationComponents(
        self, asQuaternion: Literal[True]
    ) -> Annotated[list[int], "[x, y, z, w]"]: ...
    def rotationOrder(self) -> RotationOrder: ...
    def rotationOrientation(self) -> MQuaternion: ...
    def scale(
        self, space: MSpace.Space, /
    ) -> Annotated[list[float], "[sx, sy, sz]"]: ...
    def scaleBy(
        self, seq: Annotated[Sequence[float], "[sx, sy, sz]"], space: MSpace.Space, /
    ) -> Self: ...
    def scalePivot(self, space: MSpace.Space, /) -> MPoint: ...
    def scalePivotTranslation(self, space: MSpace.Space, /) -> MVector: ...
    def setRotatePivot(
        self, trans: MPoint, space: MSpace.Space, balance: bool, /
    ) -> Self: ...
    def setRotatePivotTranslation(
        self, trans: MVector, space: MSpace.Space, /
    ) -> Self: ...
    def setRotation(self, rot: MQuaternion | MEulerRotation, /) -> Self: ...
    @overload
    def setRotationComponents(
        self,
        seq: Annotated[Sequence[float], "[rx, ry, rz, RotationOrder]"],
        asQuaternion: Literal[False] = False,
        /,
    ) -> Self: ...
    @overload
    def setRotationComponents(
        self,
        seq: Annotated[Sequence[float], "[qx, qy, qz, qw]"],
        /,
        asQuaternion: Literal[True],
    ) -> Self: ...
    def setRotationOrientation(self, rot: MQuaternion, /) -> Self: ...
    def setScale(
        self, seq: Annotated[Sequence[float], "[qx, qy, qz]"], space: MSpace.Space, /
    ) -> Self: ...
    def setScalePivot(
        self, pivot: MPoint, space: MSpace.Space, balance: bool, /
    ) -> Self: ...
    def setScalePivotTranslation(
        self, trans: MVector, space: MSpace.Space, /
    ) -> Self: ...
    def setShear(
        self, seq: Annotated[Sequence[float], "[sx, sy, sz]"], space: MSpace.Space, /
    ) -> Self: ...
    def setToRotationAxis(self, axis: MVector, rot: float, /) -> Self: ...
    def setTranslation(self, trans: MVector, space: MSpace.Space, /) -> Self: ...
    def shear(self, space: MSpace.Space, /) -> list[float]: ...
    def shearBy(
        self, seq: Annotated[Sequence[float], "[sx, sy, sz]"], space: MSpace.Space, /
    ) -> Self: ...
    def translateBy(self, vec: MVector, space: MSpace.Space, /) -> Self: ...
    def translation(self, space: MSpace.Space, /) -> MVector: ...

class MSpace:
    Space: TypeAlias = Literal[0, 1, 2, 3, 4, 5]
    kInvalid: Literal[0]
    kTransform: Literal[1]
    kPreTransform: Literal[2]
    kObject: Literal[2]
    kPostTransform: Literal[3]
    kWorld: Literal[4]
    kLast: Literal[5]

class MAngle:
    Unit: TypeAlias = Literal[0, 1, 2, 3, 4, 5]
    kInvalid: Literal[0]
    kRadians: Literal[1]
    kDegrees: Literal[2]
    kAngMinutes: Literal[3]
    kAngSeconds: Literal[4]
    kLast: Literal[5]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MAngle) -> None: ...
    @overload
    def __init__(self, value: float, unit: Unit = kRadians) -> None: ...
    def asAngMinutes(self) -> float: ...
    def asAngSeconds(self) -> float: ...
    def asDegrees(self) -> float: ...
    def asRadians(self) -> float: ...
    def asUnits(self, unit: Unit, /) -> float: ...
    @staticmethod
    def internalToUI(internalValue: float, /) -> float: ...
    @staticmethod
    def internalUnit() -> Unit: ...
    @staticmethod
    def setUIUnit(newUnit: Unit, /) -> None: ...
    @staticmethod
    def uiToInternal(uiValue: float, /) -> float: ...
    @staticmethod
    def uiUnit() -> Unit: ...
    @property
    def unit(self) -> Unit: ...
    @unit.setter
    def unit(self, value: Unit) -> None: ...
    @property
    def value(self) -> float: ...
    @value.setter
    def value(self, value: float) -> None: ...

class MDistance:
    Unit: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    kInvalid: Literal[0]
    kInches: Literal[1]
    kFeet: Literal[2]
    kYards: Literal[3]
    kMiles: Literal[4]
    kMillimeters: Literal[5]
    kCentimeters: Literal[6]
    kKilometers: Literal[7]
    kMeters: Literal[8]
    kLast: Literal[9]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MDistance) -> None: ...
    @overload
    def __init__(self, value: float, unit: Unit = kCentimeters) -> None: ...
    def asFeet(self) -> float: ...
    def asInches(self) -> float: ...
    def asKilometers(self) -> float: ...
    def asMeters(self) -> float: ...
    def asMiles(self) -> float: ...
    def asMillimeters(self) -> float: ...
    def asUnits(self, unit: Unit, /) -> float: ...
    def asYards(self) -> float: ...
    @staticmethod
    def internalToUI(internalValue: float, /) -> float: ...
    @staticmethod
    def internalUnit() -> Unit: ...
    @staticmethod
    def setUIUnit(newUnit: Unit, /) -> None: ...
    @staticmethod
    def uiToInternal(uiValue: float, /) -> float: ...
    @staticmethod
    def uiUnit() -> Unit: ...
    @property
    def unit(self) -> Unit: ...
    @unit.setter
    def unit(self, value: Unit) -> None: ...
    @property
    def value(self) -> float: ...
    @value.setter
    def value(self, value: float) -> None: ...

class MTime:
    Unit: TypeAlias = Literal[
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
    ]  # fmt: skip
    kInvalid: Literal[0]
    kHours: Literal[1]
    kMinutes: Literal[2]
    kSeconds: Literal[3]
    kMilliseconds: Literal[4]
    kGames: Annotated[Literal[5], "deprecated"]
    k15FPS: Literal[5]
    kkFilmames: Annotated[Literal[6], "deprecated"]
    k24FPS: Literal[6]
    kPALFrame: Annotated[Literal[7], "deprecated"]
    k25FPS: Literal[7]
    kNTSCFrame: Annotated[Literal[8], "deprecated"]
    k30FPS: Literal[8]
    kShowScan: Annotated[Literal[9], "deprecated"]
    k48FPS: Literal[9]
    kPALField: Annotated[Literal[10], "deprecated"]
    k50FPS: Literal[10]
    kNTSCField: Annotated[Literal[11], "deprecated"]
    k60FPS: Literal[11]
    k2FPS: Literal[12]
    k3FPS: Literal[13]
    k4FPS: Literal[14]
    k5FPS: Literal[15]
    k6FPS: Literal[16]
    k8FPS: Literal[17]
    k10FPS: Literal[18]
    k12FPS: Literal[19]
    k16FPS: Literal[20]
    k20FPS: Literal[21]
    k40FPS: Literal[22]
    k75FPS: Literal[23]
    k80FPS: Literal[24]
    k100FPS: Literal[25]
    k120FPS: Literal[26]
    k125FPS: Literal[27]
    k150FPS: Literal[28]
    k200FPS: Literal[29]
    k240FPS: Literal[30]
    k250FPS: Literal[31]
    k300FPS: Literal[32]
    k375FPS: Literal[33]
    k400FPS: Literal[34]
    k500FPS: Literal[35]
    k600FPS: Literal[36]
    k750FPS: Literal[37]
    k1200FPS: Literal[38]
    k1500FPS: Literal[39]
    k2000FPS: Literal[40]
    k3000FPS: Literal[41]
    k6000FPS: Literal[42]
    k23_976FPS: Literal[43]
    k29_97FPS: Literal[44]
    k29_97DF: Literal[45]
    k47_952FPS: Literal[46]
    k59_94FPS: Literal[47]
    k44100FPS: Literal[48]
    k48000FPS: Literal[49]
    k90FPS: Literal[50]
    k119_88FPS: Literal[51]
    kUserDef: Literal[52]
    kLast: Literal[53]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MTime) -> None: ...
    @overload
    def __init__(self, value: float, unit: Unit = k24FPS) -> None: ...
    def __add__(self, value: MTime, /) -> MTime: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __qe__(self, value: MTime, /) -> bool: ...
    def __gt__(self, value: MTime, /) -> bool: ...
    def __iadd__(self, value: MTime, /) -> Self: ...
    def __imul__(self, value: MTime, /) -> Self: ...
    def __isub__(self, value: MTime, /) -> Self: ...
    def __itruediv__(self, value: MTime, /) -> Self: ...
    def __le__(self, value: MTime, /) -> bool: ...
    def __lt__(self, value: MTime, /) -> bool: ...
    def __mul__(self, value: MTime, /) -> MTime: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __radd__(self, value: MTime, /) -> MTime: ...
    def __rmul__(self, value: MTime, /) -> MTime: ...
    def __rsub__(self, value: MTime, /) -> MTime: ...
    def __rtruediv__(self, value: MTime, /) -> MTime: ...
    def __sub__(self, value: MTime, /) -> MTime: ...
    def __truediv__(self, value: MTime, /) -> MTime: ...
    def asUnits(self, unit: Unit, /) -> float: ...
    @staticmethod
    def setUIUnit(newUnit: Unit, /) -> None: ...
    @staticmethod
    def ticksPerSecond() -> int: ...
    @staticmethod
    def uiUnit() -> Unit: ...
    @property
    def unit(self) -> Unit: ...
    @unit.setter
    def unit(self, value: Unit) -> None: ...
    @property
    def value(self) -> float: ...
    @value.setter
    def value(self, value: float) -> None: ...

class MVector:
    kOneVector: ClassVar[MVector]
    kXaxisVector: ClassVar[MVector]
    kXnegAxisVector: ClassVar[MVector]
    kYaxisVector: ClassVar[MVector]
    kYnegAxisVector: ClassVar[MVector]
    kZaxisVector: ClassVar[MVector]
    kZeroVector: ClassVar[MVector]
    kZnegAxisVector: ClassVar[MVector]
    kTolerance: ClassVar[Literal[1]]
    Axis: TypeAlias = Literal[0, 1, 2, 3]
    kXaxis: ClassVar[Literal[0]]
    kYaxis: ClassVar[Literal[1]]
    kZaxis: ClassVar[Literal[2]]
    kWaxis: ClassVar[Literal[3]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self, src: MVector | MFloatVector | MPoint | MFloatPoint | Sequence[float], /
    ) -> None: ...
    @overload
    def __init__(self, x: float, y: float, /, z: float = 0.0) -> None: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __getitem__(self, index: int, /) -> float: ...
    def __setitem__(self, index: int, value: float, /) -> None: ...
    def __len__(self) -> Literal[3]: ...
    def __add__(self, value: MVector, /) -> MVector: ...
    def __radd__(self, value: MVector, /) -> MVector: ...
    def __iadd__(self, value: MVector, /) -> Self: ...
    def __sub__(self, value: MVector, /) -> MVector: ...
    def __rsub__(self, value: MVector, /) -> MVector: ...
    def __isub__(self, value: MVector, /) -> Self: ...
    @overload
    def __mul__(self, value: MVector, /) -> float: ...
    @overload
    def __mul__(self, value: float | MMatrix, /) -> MVector: ...
    def __rmul__(self, value: float | MMatrix, /) -> MVector: ...
    # @overload
    # def __imul__(self, value: MVector, /) -> float: ...
    def __imul__(self, value: float | MMatrix, /) -> Self: ...  # type: ignore[misc]
    def __truediv__(self, value: float, /) -> MVector: ...
    def __rtruediv__(self, value: float, /) -> MVector: ...
    def __itruediv__(self, value: float, /) -> Self: ...
    def __neg__(self) -> MVector: ...
    def __rxor__(self, value: MVector, /) -> MVector: ...
    def __xor__(self, value: MVector, /) -> MVector: ...
    def angle(self, other: MVector, /) -> float: ...
    def isEquivalent(
        self, other: MVector, /, tolerance: float = kTolerance
    ) -> bool: ...
    def isParallel(self, other: MVector, /, tolerance: float = kTolerance) -> bool: ...
    def length(self) -> float: ...
    def normal(self) -> MVector: ...
    def normalize(self) -> MVector: ...
    @overload
    def rotateBy(self, rot: MQuaternion | MEulerRotation) -> MVector: ...
    @overload
    def rotateBy(self, axis: Axis, angle: float, /) -> MVector: ...
    def rotateTo(self, target: MVector, /) -> MQuaternion: ...
    def transformAsNormal(self, matrix: MMatrix, /) -> MVector: ...
    @property
    def x(self) -> float: ...
    @x.setter
    def x(self, value: float) -> None: ...
    @property
    def y(self) -> float: ...
    @y.setter
    def y(self, value: float) -> None: ...
    @property
    def z(self) -> float: ...
    @z.setter
    def z(self, value: float) -> None: ...

class MQuaternion:
    kIdentity: ClassVar[MQuaternion]
    kTolerance: ClassVar[Literal[1]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MQuaternion, /) -> None: ...
    @overload
    def __init__(self, x: float, y: float, z: float, w: float, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[float], /) -> None: ...
    @overload
    def __init__(self, a: MVector, b: MVector, /, factor: float = 1.0) -> None: ...
    @overload
    def __init__(self, angle: float, axis: MVector, /) -> None: ...
    def __add__(self, value: MQuaternion, /) -> MQuaternion: ...
    def __radd__(self, value: MQuaternion, /) -> MQuaternion: ...
    def __sub__(self, value: MQuaternion, /) -> MQuaternion: ...
    def __rsub__(self, value: MQuaternion, /) -> MQuaternion: ...
    def __mul__(self, value: MQuaternion, /) -> MQuaternion: ...
    def __rmul__(self, value: float, /) -> MQuaternion: ...
    def __neg__(self) -> MQuaternion: ...
    def __imul__(self, value: MQuaternion, /) -> Self: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def __getitem__(self, index: int, /) -> float: ...
    def __setitem__(self, index: int, value: float, /) -> None: ...
    def __len__(self) -> Literal[4]: ...
    def asAxisAngle(self) -> tuple[MVector, float]: ...
    def asEulerRotation(self) -> MEulerRotation: ...
    def asMatrix(self) -> MMatrix: ...
    def conjugate(self) -> MQuaternion: ...
    def conjugateIt(self) -> Self: ...
    def exp(self) -> MQuaternion: ...
    def inverse(self) -> MQuaternion: ...
    def invertIt(self) -> Self: ...
    def isEquivalent(
        self, other: MQuaternion, /, tolerance: float = kTolerance
    ) -> bool: ...
    def log(self) -> MQuaternion: ...
    def negateIt(self) -> Self: ...
    def normal(self) -> MQuaternion: ...
    def normalizeIt(self) -> Self: ...
    def setToXAxis(self, angle: float, /) -> Self: ...
    def setToYAxis(self, angle: float, /) -> Self: ...
    def setToZAxis(self, angle: float, /) -> Self: ...
    @overload
    def setValue(self, quat: MQuaternion, /) -> Self: ...
    @overload
    def setValue(self, mat: MMatrix, /) -> Self: ...
    @overload
    def setValue(self, rot: MEulerRotation, /) -> Self: ...
    @overload
    def setValue(self, axis: MVector, angle: float, /) -> Self: ...
    def slerp(
        self, p: MQuaternion, q: MQuaternion, t: float, /, spin: int = 0
    ) -> MQuaternion: ...
    def squad(
        self,
        p: MQuaternion,
        a: MQuaternion,
        b: MQuaternion,
        q: MQuaternion,
        t: float,
        /,
        spin: int = 0,
    ) -> MQuaternion: ...
    def squadPt(
        self, q0: MQuaternion, q1: MQuaternion, q2: MQuaternion, /
    ) -> MQuaternion: ...
    @property
    def x(self) -> float: ...
    @x.setter
    def x(self, value: float) -> None: ...
    @property
    def y(self) -> float: ...
    @y.setter
    def y(self, value: float) -> None: ...
    @property
    def z(self) -> float: ...
    @z.setter
    def z(self, value: float) -> None: ...
    @property
    def w(self) -> float: ...
    @w.setter
    def w(self, value: float) -> None: ...

class MFnMessageAttribute(MFnAttribute):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    def create(self, longName: str, shortName: str, /) -> MObject: ...

class MFnEnumAttribute(MFnAttribute):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    def addField(self, name: str, value: int, /) -> Self: ...
    def create(
        self, longName: str, shortName: str, /, defaultValue: int = 0
    ) -> MObject: ...
    def fieldName(self, value: int, /) -> str: ...
    def fieldValue(self, name: str, /) -> int: ...
    def getMax(self) -> int: ...
    def getMin(self) -> int: ...
    def setDefaultByName(self, name: str, /) -> Self: ...
    @property
    def default(self) -> int: ...
    @default.setter
    def default(self, value: int) -> None: ...

class MFnCompoundAttribute(MFnAttribute):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    def addChild(self, child: MObject, /) -> Self: ...
    def child(self, index: int, /) -> MObject: ...
    def create(self, longName: str, shortName: str, /) -> MObject: ...
    def getAddAttrCmds(self, longNames: bool) -> list[str]: ...
    def numChildren(self) -> int: ...
    def removeChild(self, child: MObject, /) -> Self: ...

class MFnGenericAttribute(MFnAttribute):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    def addDataType(self, type: MFnData.Type, /) -> Self: ...
    def addNumericType(self, type: MFnData.Type, /) -> Self: ...
    def addTypeId(self, typeId: MTypeId, /) -> Self: ...
    def create(self, longName: str, shortName: str, /) -> MObject: ...
    def removeDataType(self, type: MFnData.Type, /) -> Self: ...
    def removeNumericType(self, type: MFnData.Type, /) -> Self: ...
    def removeTypeId(self, typeId: MTypeId, /) -> Self: ...

class MFnLightDataAttribute(MFnAttribute):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    def child(self, index: int, /) -> MObject: ...
    def create(
        self,
        longName: str,
        shortName: str,
        direction: MObject,
        intensity: MObject,
        ambient: MObject,
        diffuse: MObject,
        specular: MObject,
        shadowFraction: MObject,
        preShadowIntensity: MObject,
        blindData: MObject,
        /,
    ) -> MObject: ...
    @property
    def default(self) -> Incomplete: ...
    @default.setter
    def default(self, value: Incomplete) -> None: ...

class MFnMatrixAttribute(MFnAttribute):
    Type: TypeAlias = Literal[0, 1]
    kFloat: Literal[0]
    kDouble: Literal[1]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    def create(
        self,
        longName: str,
        shortName: str,
        /,
        type: Type = kDouble,
    ) -> MObject: ...
    @property
    def default(self) -> MMatrix: ...
    @default.setter
    def default(self, value: MMatrix | MFloatMatrix) -> None: ...

class MFnNumericAttribute(MFnAttribute):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    def child(self, index: int, /) -> MObject: ...
    def create(
        self, longName: str, shortName: str, type: int, /, defaultValue: float = 0
    ) -> MObject: ...
    def createAddr(
        self, longName: str, shortName: str, /, defaultValue: float = 0
    ) -> MObject: ...
    def createColor(self, longName: str, shortName: str, /) -> MObject: ...
    def createPoint(self, longName: str, shortName: str, /) -> MObject: ...
    def getMax(self) -> float | tuple[float, ...]: ...  # TODO: 2 to 4 floats
    def getMin(self) -> float | tuple[float, ...]: ...  # TODO: 2 to 4 floats
    def getSoftMax(self) -> float: ...
    def getSoftMin(self) -> float: ...
    def hasMax(self) -> bool: ...
    def hasMin(self) -> bool: ...
    def hasSoftMax(self) -> bool: ...
    def hasSoftMin(self) -> bool: ...
    def numericType(self) -> MFnNumericData.Type: ...
    def setMax(self, maxValue: float | Sequence[float], /) -> Self: ...
    def setMin(self, minValue: float | Sequence[float], /) -> Self: ...
    def setSoftMax(self, maxValue: float, /) -> Self: ...
    def setSoftMin(self, minValue: float, /) -> Self: ...
    @property
    def default(self) -> float | tuple[float, ...]: ...
    @default.setter
    def default(self, value: float | tuple[float, ...]) -> None: ...

class MFnUnitAttribute(MFnAttribute):
    Type: TypeAlias = Literal[0, 1, 2, 3, 4]
    kInvalid: Literal[0]
    kAngle: Literal[1]
    kDistance: Literal[2]
    kTime: Literal[3]
    kLast: Literal[4]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    @overload
    def create(
        self, longName: str, shortName: str, type: Type, /, defaultValue: float = 0.0
    ) -> MObject: ...
    @overload
    def create(
        self,
        longName: str,
        shortName: str,
        defaultValue: MAngle | MTime | MDistance,
        /,
    ) -> MObject: ...
    def getMax(self) -> MAngle | MTime | MDistance: ...
    def getMin(self) -> MAngle | MTime | MDistance: ...
    def getSoftMax(self) -> MAngle | MTime | MDistance: ...
    def getSoftMin(self) -> MAngle | MTime | MDistance: ...
    def hasMax(self) -> bool: ...
    def hasMin(self) -> bool: ...
    def hasSoftMax(self) -> bool: ...
    def hasSoftMin(self) -> bool: ...
    def setMax(self, maxValue: float | MAngle | MTime | MDistance, /) -> Self: ...
    def setMin(self, maxValue: float | MAngle | MTime | MDistance, /) -> Self: ...
    def setSoftMax(self, maxValue: float | MAngle | MTime | MDistance, /) -> Self: ...
    def setSoftMin(self, maxValue: float | MAngle | MTime | MDistance, /) -> Self: ...
    def unitType(self) -> Type: ...
    @property
    def default(self) -> MAngle | MTime | MDistance: ...
    @default.setter
    def default(self, value: MAngle | MTime | MDistance) -> None: ...

class MFnTypedAttribute(MFnAttribute):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    def attrType(self) -> MFnData.Type: ...
    def create(
        self,
        longName: str,
        shortName: str,
        type: MTypeId | MFnData.Type,
        defaultValue: MObject = MObject.kNullObj,
    ) -> MFnData.Type: ...
    @property
    def default(self) -> MObject: ...
    @default.setter
    def default(self, value: MObject) -> None: ...

class MDGContext:
    kNormal: MDGContext

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MDGContext, /) -> None: ...
    @overload
    def __init__(self, time: MTime) -> None: ...
    def copy(self, source: MDGContext, /) -> Self: ...
    @staticmethod
    def current() -> MDGContext: ...
    def getTime(self) -> MTime: ...
    def isCurrent(self) -> bool: ...
    def isNormal(self) -> bool: ...
    def makeCurrent(self) -> Self: ...

class MDGModifier:
    def __init__(self) -> None: ...
    def addAttribute(self, node: MObject, attribute: MObject, /) -> Self: ...
    def addExtensionAttribute(
        self, nodeClass: MNodeClass, attribute: MObject, /
    ) -> Self: ...
    def commandToExecute(self, command: str, /) -> Self: ...
    @overload
    def connect(self, source: MPlug, dest: MPlug, /) -> Self: ...
    @overload
    def connect(
        self,
        sourceNode: MObject,
        sourceAttr: MObject,
        destNode: MObject,
        destAttr: MObject,
        /,
    ) -> Self: ...
    @overload
    def createNode(self, typeName: str, /) -> MObject: ...
    @overload
    def createNode(self, typeId: MTypeId, /) -> MObject: ...
    @overload
    def deleteNode(self, node: MObject, /) -> Self: ...
    @overload
    def deleteNode(self, node: MObject, includeParents: bool, /) -> Self: ...
    @overload
    def disconnect(self, source: MPlug, dest: MPlug, /) -> Self: ...
    @overload
    def disconnect(
        self,
        sourceNode: MObject,
        sourceAttr: MObject,
        destNode: MObject,
        destAttr: MObject,
        /,
    ) -> Self: ...
    def doIt(self) -> Self: ...
    def linkExtensionAttributeToPlugin(
        self, plugin: MObject, attribute: MObject, /
    ) -> Self: ...
    def newPlugValue(self, plug: MPlug, value: MObject, /) -> Self: ...
    def newPlugValueBool(self, plug: MPlug, value: bool, /) -> Self: ...
    def newPlugValueChar(self, plug: MPlug, value: int, /) -> Self: ...
    def newPlugValueDouble(self, plug: MPlug, value: float, /) -> Self: ...
    def newPlugValueFloat(self, plug: MPlug, value: float, /) -> Self: ...
    def newPlugValueInt(self, plug: MPlug, value: int, /) -> Self: ...
    def newPlugValueMAngle(self, plug: MPlug, value: MAngle, /) -> Self: ...
    def newPlugValueMDistance(self, plug: MPlug, value: MDistance, /) -> Self: ...
    def newPlugValueMTime(self, plug: MPlug, value: MTime, /) -> Self: ...
    def newPlugValueShort(self, plug: MPlug, value: int, /) -> Self: ...
    def newPlugValueString(self, plug: MPlug, value: str, /) -> Self: ...
    @overload
    def pythonCommandToExecute(self, callable: Callable[[], Any], /) -> Self: ...
    @overload
    def pythonCommandToExecute(self, commandString: str, /) -> Self: ...
    def removeAttribute(self, node: MObject, attribute: MObject, /) -> Self: ...
    def removeExtensionAttribute(
        self, nodeClass: MNodeClass, attribute: MObject, /
    ) -> Self: ...
    def removeExtensionAttributeIfUnset(
        self, nodeClass: MNodeClass, attribute: MObject, /
    ) -> Self: ...
    def removeMultiInstance(self, plug: MPlug, breakConnections: bool, /) -> Self: ...
    def renameAttribute(
        self, node: MObject, attribute: MObject, shortName: str, longName: str, /
    ) -> Self: ...
    def renameNode(self, node: MObject, newName: str, /) -> Self: ...
    def setNodeLockState(self, node: MObject, newState: bool, /) -> Self: ...
    def undoIt(self) -> Self: ...
    def unlinkExtensionAttributeFromPlugin(
        self, plugin: MObject, attribute: MObject, /
    ) -> Self: ...

class MDagModifier(MDGModifier):
    def __init__(self) -> None: ...
    @overload
    def createNode(
        self, typeName: str, /, parent: MObject = MObject.kNullObj
    ) -> MObject: ...
    @overload
    def createNode(
        self, typeId: MTypeId, /, parent: MObject = MObject.kNullObj
    ) -> MObject: ...
    def reparentNode(
        self, node: MObject, /, newParent: MObject = MObject.kNullObj
    ) -> Self: ...

_MPlugMValueSelector: TypeAlias = Literal[0, 1, 2, 3]
_MPlugFreeToChangeState: TypeAlias = Literal[0, 1, 2]

class MPlug:
    kAll: Literal[0]
    kNonDefault: Literal[1]
    kChanged: Literal[2]
    kLastAttrSelector: Literal[3]

    kFreeToChange: Literal[0]
    kNotFreeToChange: Literal[1]
    kChildrenNotFreeToChange: Literal[2]

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MPlug, /) -> None: ...
    @overload
    def __init__(self, node: MObject, attribute: MObject, /) -> None: ...
    def __eq__(self, value: object, /) -> bool: ...
    def __ne__(self, value: object, /) -> bool: ...
    def array(self) -> MPlug: ...
    def asBool(self, context: MDGContext = MDGContext.kNormal) -> bool: ...
    def asChar(self, context: MDGContext = MDGContext.kNormal) -> int: ...
    def asDouble(self, context: MDGContext = MDGContext.kNormal) -> float: ...
    def asFloat(self, context: MDGContext = MDGContext.kNormal) -> float: ...
    def asInt(self, context: MDGContext = MDGContext.kNormal) -> int: ...
    def asMAngle(self, context: MDGContext = MDGContext.kNormal) -> MAngle: ...
    def asMDataHandle(
        self, context: MDGContext = MDGContext.kNormal
    ) -> MDataHandle: ...
    def asMDistance(self, context: MDGContext = MDGContext.kNormal) -> MDistance: ...
    def asMObject(self, context: MDGContext = MDGContext.kNormal) -> MObject: ...
    def asMTime(self, context: MDGContext = MDGContext.kNormal) -> MTime: ...
    def asShort(self, context: MDGContext = MDGContext.kNormal) -> int: ...
    def asString(self, context: MDGContext = MDGContext.kNormal) -> str: ...
    def attribute(self) -> MObject: ...
    @overload
    def child(self, attribute: MObject, /) -> MPlug: ...
    @overload
    def child(self, index: int, /) -> MPlug: ...
    def connectedTo(self, asDest: bool, asSrc: bool, /) -> MPlugArray: ...
    def connectionByPhysicalIndex(self, index: int, /) -> MPlug: ...
    def constructHandle(self, block: MDataBlock, /) -> MDataHandle: ...
    def copy(self, plug: MPlug, /) -> MPlug: ...
    def destinations(self) -> MPlugArray: ...
    def destinationsWithConversions(self) -> MPlugArray: ...
    def destructHandle(self, handle: MDataHandle, /) -> Self: ...
    def elementByLogicalIndex(self, index: int, /) -> MPlug: ...
    def elementByPhysicalIndex(self, index: int, /) -> MPlug: ...
    def evaluateNumElements(self) -> int: ...
    def getExistingArrayAttributeIndices(self) -> MIntArray: ...
    def getSetAttrCmds(
        self, valueSelector: _MPlugMValueSelector = kAll, useLongNames: bool = False
    ) -> list[str]: ...
    def isDefaultValue(self) -> bool: ...
    def isExactlyEqual(self, plug: MPlug) -> bool: ...
    def isFreeToChange(
        self, checkAncestors: bool = True, checkChildren: bool = True
    ) -> _MPlugFreeToChangeState: ...
    def logicalIndex(self) -> int: ...
    def name(self) -> str: ...
    def node(self) -> MObject: ...
    def numChildren(self) -> int: ...
    def numConnectedChildren(self) -> int: ...
    def numConnectedElements(self) -> int: ...
    def numElements(self) -> int: ...
    def parent(self) -> MPlug: ...
    def partialName(
        self,
        includeNodeName: bool = False,
        includeNonMandatoryIndices: bool = False,
        includeInstancedIndices: bool = False,
        useAlias: bool = False,
        useFullAttributePath: bool = False,
        useLongNames: bool = False,
    ) -> str: ...
    def proxied(self) -> MPlug: ...
    def selectAncestorLogicalIndex(
        self, index: int, /, attribute: MObject = MObject.kNullObj
    ) -> MPlug: ...
    def setAttribute(self, attr: MObject, /) -> Self: ...
    def setBool(self, value: bool, /) -> Self: ...
    def setChar(self, value: int, /) -> Self: ...
    def setDouble(self, value: float, /) -> Self: ...
    def setFloat(self, value: float, /) -> Self: ...
    def setInt(self, value: int, /) -> Self: ...
    def setMAngle(self, value: MAngle, /) -> Self: ...
    def setMDataHandle(self, value: MDataHandle, /) -> Self: ...
    def setMDistance(self, value: MDistance, /) -> Self: ...
    def setMObject(self, value: MObject, /) -> Self: ...
    def setMPxData(self, value: MPxData, /) -> Self: ...
    def setMTime(self, value: MTime, /) -> Self: ...
    def setNumElements(self, count: int, /) -> Self: ...
    def setShort(self, value: int, /) -> Self: ...
    def setString(self, value: str, /) -> Self: ...
    def source(self) -> MPlug: ...
    def sourceWithConversion(self) -> MPlug: ...
    @property
    def info(self) -> str: ...
    @property
    def isArray(self) -> bool: ...
    @property
    def isCaching(self) -> bool: ...
    @isCaching.setter
    def isCaching(self, value: bool) -> None: ...
    @property
    def isChannelBox(self) -> bool: ...
    @isChannelBox.setter
    def isChannelBox(self, value: bool) -> None: ...
    @property
    def isChild(self) -> bool: ...
    @property
    def isCompound(self) -> bool: ...
    @property
    def isConnected(self) -> bool: ...
    @property
    def isDestination(self) -> bool: ...
    @property
    def isDynamic(self) -> bool: ...
    @property
    def isElement(self) -> bool: ...
    @property
    def isFromReferencedFile(self) -> bool: ...
    @property
    def isIgnoredWhenRendering(self) -> bool: ...
    @property
    def isKeyable(self) -> bool: ...
    @isKeyable.setter
    def isKeyable(self, value: bool) -> None: ...
    @property
    def isLocked(self) -> bool: ...
    @isLocked.setter
    def isLocked(self, value: bool) -> None: ...
    @property
    def isNetworked(self) -> bool: ...
    @property
    def isNull(self) -> bool: ...
    @property
    def isProcedural(self) -> bool: ...
    @property
    def isProxy(self) -> bool: ...
    @property
    def isSource(self) -> bool: ...

class MSyntax:
    MArgType: TypeAlias = Literal[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    kInvalidArgType: Literal[0]
    kNoArg: Literal[1]
    kBoolean: Literal[2]
    kLong: Literal[3]
    kDouble: Literal[4]
    kString: Literal[5]
    kUnsigned: Literal[6]
    kDistance: Literal[7]
    kAngle: Literal[8]
    kTime: Literal[9]
    kSelectionItem: Literal[10]
    kLastArgType: Literal[11]
    MObjectFormat: TypeAlias = Literal[1, 2, 3, 4]
    kInvalidObjectFormat: Literal[0]
    kNone: Literal[1]
    kStringObjects: Literal[2]
    kSelectionList: Literal[3]
    kLastObjectFormat: Literal[4]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MSyntax, /) -> None: ...
    def addArg(self, argType: MArgType) -> Self: ...
    def addFlag(
        self,
        shortName: str,
        longName: str,
        argTypes: MArgType | Annotated[Sequence[MArgType], "[1..6]"],
    ) -> Self: ...
    def makeFlagMultiUse(self, flagName: str, /) -> Self: ...
    def makeFlagQueryWithFullArgs(
        self, flagName: str, argsOptional: bool, /
    ) -> Self: ...
    def maxObjects(self) -> int: ...
    def minObjects(self) -> int: ...
    def setMaxObjects(self, max: int, /) -> Self: ...
    def setMinObjects(self, min: int, /) -> Self: ...
    def setObjectType(self, objType: MObjectFormat, min: int, max: int, /) -> Self: ...
    def useSelectionAsDefault(self, useSelection: bool, /) -> Self: ...
    @property
    def enableEdit(self) -> bool: ...
    @enableEdit.setter
    def enableEdit(self, value: bool) -> None: ...
    @property
    def enableQuery(self) -> bool: ...
    @enableQuery.setter
    def enableQuery(self, value: bool) -> None: ...

class MFnDependencyNode(MFnBase):
    kTimerTypes: Literal[3]
    kTimerMetrics: Literal[9]
    MAttrClass: TypeAlias = Literal[1, 2, 3, 4]
    kLocalDynamicAttr: Literal[1]
    kNormalAttr: Literal[2]
    kExtensionAttr: Literal[3]
    kInvalidAttr: Literal[4]
    MdgTimerState: TypeAlias = Literal[0, 1, 2, 3]
    kTimerOff: Literal[0]
    kTimerOn: Literal[1]
    kTimerUninitialized: Literal[2]
    kTimerInvalidState: Literal[3]
    MdgTimerMetric: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8]
    kTimerMetric_callback: Literal[0]
    kTimerMetric_compute: Literal[1]
    kTimerMetric_dirty: Literal[2]
    kTimerMetric_draw: Literal[3]
    kTimerMetric_fetch: Literal[4]
    kTimerMetric_callbackViaAPI: Literal[5]
    kTimerMetric_callbackNotViaAPI: Literal[6]
    kTimerMetric_computeDuringCallback: Literal[7]
    kTimerMetric_computeNotDuringCallback: Literal[8]
    MdgTimerType: TypeAlias = Literal[0, 1, 2]
    kTimerType_self: Literal[0]
    kTimerType_inclusive: Literal[1]
    kTimerType_count: Literal[2]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, node: MObject, /) -> None: ...
    def absoluteName(self) -> str: ...
    def addAttribute(self, attribute: MObject, /) -> Self: ...
    def addExternalContentForFileAttr(
        self, table: MExternalContentInfoTable, attr: MObject, /
    ) -> Self: ...
    def affectsAnimation(self) -> bool: ...
    def allocateFlag(self, plugin: str, /) -> int: ...
    @overload
    def attribute(self, index: int, /) -> MObject: ...
    @overload
    def attribute(self, name: str, /) -> MObject: ...
    def attributeClass(self, attribute: MObject, /) -> MAttrClass: ...
    def attributeCount(self) -> int: ...
    def canBeWritten(self) -> bool: ...
    @staticmethod
    def classification(nodeType: str, /) -> str: ...
    @overload
    def create(self, typeId: MTypeId, /, nodeName: str | None = None) -> MObject: ...
    @overload
    def create(self, typeName: str, /, nodeName: str | None = None) -> MObject: ...
    def deallocateAllFlags(self, plugin: str, /) -> None: ...
    def deallocateFlag(self, plugin: str, flag: int, /) -> None: ...
    def dgCallbackIds(
        self, timerType: MdgTimerType, callbackName: str, /
    ) -> tuple[MCallbackIdArray, MDoubleArray]: ...
    def dgCallbacks(self, type: MdgTimerType, /) -> tuple[list[str], MDoubleArray]: ...
    def dgTimer(self, metric: MdgTimerMetric, type: MdgTimerType, /) -> float: ...
    def dgTimerOff(self) -> Self: ...
    def dgTimerOn(self) -> Self: ...
    def dgTimerQueryState(self) -> MdgTimerState: ...
    def dgTimerReset(self) -> Self: ...
    def findAlias(self, alias: str, /) -> MObject: ...
    def findPlug(self, attr: str | MObject, wantNetworkedPlug: bool, /) -> MPlug: ...
    def getAffectedAttributes(self, attribute: MObject, /) -> MObjectArray: ...
    def getAffectingAttributes(self, attribute: MObject, /) -> MObjectArray: ...
    def getAliasAttr(self, force: bool, /) -> MObject: ...
    def getAliasList(self) -> tuple[tuple[str, str], ...]: ...
    def getConnections(self) -> MPlugArray: ...
    def getExternalContent(self, arg: Incomplete, /) -> Incomplete: ...
    def hasAttribute(self, name: str, /) -> bool: ...
    def hasUniqueName(self) -> bool: ...
    def isFlagSet(self, flag: int, /) -> bool: ...
    def isNewAttribute(self, attribute: MObject, /) -> bool: ...
    def isTrackingEdits(self) -> bool: ...
    def name(self) -> str: ...
    def plugsAlias(self, plug: MPlug, /) -> str: ...
    def removeAttribute(self, attribute: MObject, /) -> Self: ...
    def reorderedAttribute(self, index: int, /) -> MObject: ...
    def setAffectsAnimation(self) -> Self: ...
    def setAlias(
        self, alias: str, attrName: str, plug: MPlug, /, add: bool = True
    ) -> bool: ...
    def setDoNotWrite(self, flag: bool) -> Self: ...
    def setExternalContent(self, table: MExternalContentLocationTable, /) -> Self: ...
    def setExternalContentForFileAttr(
        self, attr: MObject, table: MExternalContentLocationTable, /
    ) -> Self: ...
    def setFlag(self, flag: int, state: bool, /) -> Self: ...
    def setName(self, name: str, /) -> str: ...
    def setUuid(self, uuid: MUuid, /) -> Self: ...
    def uniqueName(self) -> str: ...
    def userNode(self) -> MPxNode | None: ...
    def uuid(self) -> MUuid: ...
    @property
    def isDefaultNode(self) -> bool: ...
    @property
    def isFromReferencedFile(self) -> bool: ...
    @property
    def isLocked(self) -> bool: ...
    @isLocked.setter
    def isLocked(self, value: bool) -> None: ...
    @property
    def isShared(self) -> bool: ...
    @property
    def namespace(self) -> str: ...
    @property
    def pluginName(self) -> str: ...
    @property
    def typeId(self) -> MTypeId: ...
    @property
    def typeName(self) -> str: ...

class MFnDagNode(MFnDependencyNode):
    kNextPos: Literal[255]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: MObject, /) -> None: ...
    @overload
    def __init__(self, path: MDagPath, /) -> None: ...
    def addChild(
        self, node: MObject, /, index: int = kNextPos, keepExistingParents: bool = False
    ) -> Self: ...
    def child(self, index: int, /) -> MObject: ...
    def childCount(self) -> int: ...
    def create(  # pyright: ignore[reportIncompatibleMethodOverride]
        self,
        type: str | MTypeId,
        /,
        name: str | None = None,
        parent: MObject = MObject.kNullObj,
    ) -> MObject: ...
    def dagPath(self) -> MDagPath: ...
    def dagRoot(self) -> MObject: ...
    def duplicate(
        self, instance: bool = False, instanceLeaf: bool = False
    ) -> MObject: ...
    def fullPathName(self) -> str: ...
    def getAllPaths(self) -> MDagPathArray: ...
    def getConnectedSetsAndMembers(
        self, instance: int, renderableSetsOnly: bool, /
    ) -> tuple[MObjectArray, MObjectArray]: ...
    def getPath(self) -> MDagPath: ...
    def hasChild(self, node: MObject, /) -> bool: ...
    def hasParent(self, node: MObject, /) -> bool: ...
    def instanceCount(self, indirect: bool, /) -> int: ...
    def isChildOf(self, node: MObject, /) -> bool: ...
    def isInstanced(self, indirect: bool = True) -> bool: ...
    def isInstancedAttribute(self, attr: MObject, /) -> bool: ...
    def isParentOf(self, node: MObject, /) -> bool: ...
    def parent(self, index: int, /) -> MObject: ...
    def parentCount(self) -> int: ...
    def partialPathName(self) -> str: ...
    def removeChild(self, node: MObject, /) -> Self: ...
    def removeChildAt(self, index: int, /) -> Self: ...
    @overload
    def setObject(self, object: MObject, /) -> Self: ...
    @overload
    def setObject(self, path: MDagPath, /) -> Self: ...
    def transformationMatrix(self) -> MMatrix: ...
    @property
    def boundingBox(self) -> MBoundingBox: ...
    @property
    def inModel(self) -> bool: ...
    @property
    def inUnderWorld(self) -> bool: ...
    @property
    def isInstanceable(self) -> bool: ...
    @isInstanceable.setter
    def isInstanceable(self, value: bool) -> None: ...
    @property
    def isIntermediateObject(self) -> bool: ...
    @isIntermediateObject.setter
    def isIntermediateObject(self, value: bool) -> None: ...
    @property
    def objectColor(self) -> Literal[0, 1, 2, 3, 4, 5, 6, 7]: ...
    @objectColor.setter
    def objectColor(self, value: Literal[0, 1, 2, 3, 4, 5, 6, 7]) -> None: ...
    @property
    def objectColorRGB(self) -> MColor: ...
    @objectColorRGB.setter
    def objectColorRGB(self, value: MColor) -> None: ...
    @property
    def objectColorType(self) -> int: ...  # TODO: Literal[0, 1, 2] ?
    @objectColorType.setter
    def objectColorType(self, value: int) -> None: ...
    @property
    def useObjectColor(self) -> bool: ...
    @useObjectColor.setter
    def useObjectColor(self, value: bool) -> None: ...

class MObjectArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MObjectArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MObject, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MObject], /) -> None: ...
    def __add__(self, value: list[MObject], /) -> MObjectArray: ...
    def __contains__(self, key: MObject, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MObject: ...
    def __iadd__(self, value: Iterable[MObject], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MObjectArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MObjectArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MObject],
        /,
    ) -> None: ...
    def append(self, value: MObject, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MObjectArray | Sequence[MObject], /) -> None: ...
    def insert(self, value: MObject, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MCallbackIdArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MCallbackIdArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MCallbackId, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MCallbackId], /) -> None: ...
    def __add__(self, value: list[MCallbackId], /) -> MCallbackIdArray: ...
    def __contains__(self, key: MCallbackId, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MCallbackId: ...
    def __iadd__(self, value: Iterable[MCallbackId], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MCallbackIdArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MCallbackIdArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MCallbackId],
        /,
    ) -> None: ...
    def append(self, value: MCallbackId, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MCallbackIdArray | Sequence[MCallbackId], /) -> None: ...
    def insert(self, value: MCallbackId, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MColorArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MColorArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MColor, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MColor], /) -> None: ...
    def __add__(self, value: list[MColor], /) -> MColorArray: ...
    def __contains__(self, key: MColor, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MColor: ...
    def __iadd__(self, value: Iterable[MColor], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MColorArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MColorArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MColor],
        /,
    ) -> None: ...
    def append(self, value: MColor, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MColorArray | Sequence[MColor], /) -> None: ...
    def insert(self, value: MColor, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MDagPathArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MDagPathArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MDagPath, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MDagPath], /) -> None: ...
    def __add__(self, value: list[MDagPath], /) -> MDagPathArray: ...
    def __contains__(self, key: MDagPath, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MDagPath: ...
    def __iadd__(self, value: Iterable[MDagPath], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MDagPathArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MDagPathArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MDagPath],
        /,
    ) -> None: ...
    def append(self, value: MDagPath, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MDagPathArray | Sequence[MDagPath], /) -> None: ...
    def insert(self, value: MDagPath, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MDoubleArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MDoubleArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: float, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[float], /) -> None: ...
    def __add__(self, value: list[float], /) -> MDoubleArray: ...
    def __contains__(self, key: float, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> float: ...
    def __iadd__(self, value: Iterable[float], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MDoubleArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MDoubleArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[float],
        /,
    ) -> None: ...
    def append(self, value: float, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MDoubleArray | Sequence[float], /) -> None: ...
    def insert(self, value: float, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MFloatArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MFloatArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: float, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[float], /) -> None: ...
    def __add__(self, value: list[float], /) -> MFloatArray: ...
    def __contains__(self, key: float, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> float: ...
    def __iadd__(self, value: Iterable[float], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MFloatArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MFloatArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[float],
        /,
    ) -> None: ...
    def append(self, value: float, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MFloatArray | Sequence[float], /) -> None: ...
    def insert(self, value: float, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MFloatPointArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MAttributeSpecArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MAttributeSpec, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MAttributeSpec], /) -> None: ...
    def __add__(self, value: list[MAttributeSpec], /) -> MAttributeSpecArray: ...
    def __contains__(self, key: MAttributeSpec, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MAttributeSpec: ...
    def __iadd__(self, value: Iterable[MAttributeSpec], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MAttributeSpecArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MAttributeSpecArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MAttributeSpec],
        /,
    ) -> None: ...
    def append(self, value: MAttributeSpec, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MAttributeSpecArray | Sequence[MAttributeSpec], /) -> None: ...
    def insert(self, value: MAttributeSpec, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MFloatVectorArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MFloatVectorArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MFloatVector, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MFloatVector], /) -> None: ...
    def __add__(self, value: list[MFloatVector], /) -> MFloatVectorArray: ...
    def __contains__(self, key: MFloatVector, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MFloatVector: ...
    def __iadd__(self, value: Iterable[MFloatVector], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MFloatVectorArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MFloatVectorArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MFloatVector],
        /,
    ) -> None: ...
    def append(self, value: MFloatVector, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MFloatVectorArray | Sequence[MFloatVector], /) -> None: ...
    def insert(self, value: MFloatVector, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MInt64Array:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MInt64Array, /) -> None: ...
    @overload
    def __init__(self, size: int, value: int, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[int], /) -> None: ...
    def __add__(self, value: list[int], /) -> MInt64Array: ...
    def __contains__(self, key: int, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> int: ...
    def __iadd__(self, value: Iterable[int], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MInt64Array: ...
    def __rmul__(self, value: SupportsIndex, /) -> MInt64Array: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[int],
        /,
    ) -> None: ...
    def append(self, value: int, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MInt64Array | Sequence[int], /) -> None: ...
    def insert(self, value: int, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MIntArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MIntArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: int, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[int], /) -> None: ...
    def __add__(self, value: list[int], /) -> MIntArray: ...
    def __contains__(self, key: int, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> int: ...
    def __iadd__(self, value: Iterable[int], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MIntArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MIntArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[int],
        /,
    ) -> None: ...
    def append(self, value: int, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MIntArray | Sequence[int], /) -> None: ...
    def insert(self, value: int, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MMatrixArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MMatrixArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MMatrix, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MMatrix], /) -> None: ...
    def __add__(self, value: list[MMatrix], /) -> MMatrixArray: ...
    def __contains__(self, key: MMatrix, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MMatrix: ...
    def __iadd__(self, value: Iterable[MMatrix], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MMatrixArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MMatrixArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MMatrix],
        /,
    ) -> None: ...
    def append(self, value: MMatrix, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MMatrixArray | Sequence[MMatrix], /) -> None: ...
    def insert(self, value: MMatrix, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MPlugArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MPlugArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MPlug, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MPlug], /) -> None: ...
    def __add__(self, value: list[MPlug], /) -> MPlugArray: ...
    def __contains__(self, key: MPlug, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MPlug: ...
    def __iadd__(self, value: Iterable[MPlug], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MPlugArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MPlugArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MPlug],
        /,
    ) -> None: ...
    def append(self, value: MPlug, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MPlugArray | Sequence[MPlug], /) -> None: ...
    def insert(self, value: MPlug, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MPointArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MPointArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MPoint, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MPoint], /) -> None: ...
    def __add__(self, value: list[MPoint], /) -> MPointArray: ...
    def __contains__(self, key: MPoint, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MPoint: ...
    def __iadd__(self, value: Iterable[MPoint], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MPointArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MPointArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MPoint],
        /,
    ) -> None: ...
    def append(self, value: MPoint, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MPointArray | Sequence[MPoint], /) -> None: ...
    def insert(self, value: MPoint, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MTimeArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MTimeArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MTime, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MTime], /) -> None: ...
    def __add__(self, value: list[MTime], /) -> MTimeArray: ...
    def __contains__(self, key: MTime, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MTime: ...
    def __iadd__(self, value: Iterable[MTime], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MTimeArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MTimeArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MTime],
        /,
    ) -> None: ...
    def append(self, value: MTime, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MTimeArray | Sequence[MTime], /) -> None: ...
    def insert(self, value: MTime, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MUint64Array:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MUint64Array, /) -> None: ...
    @overload
    def __init__(self, size: int, value: int, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[int], /) -> None: ...
    def __add__(self, value: list[int], /) -> MUint64Array: ...
    def __contains__(self, key: int, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> int: ...
    def __iadd__(self, value: Iterable[int], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MUint64Array: ...
    def __rmul__(self, value: SupportsIndex, /) -> MUint64Array: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[int],
        /,
    ) -> None: ...
    def append(self, value: int, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MUint64Array | Sequence[int], /) -> None: ...
    def insert(self, value: int, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MUintArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MUintArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: int, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[int], /) -> None: ...
    def __add__(self, value: list[int], /) -> MUintArray: ...
    def __contains__(self, key: int, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> int: ...
    def __iadd__(self, value: Iterable[int], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MUintArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MUintArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[int],
        /,
    ) -> None: ...
    def append(self, value: int, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MUintArray | Sequence[int], /) -> None: ...
    def insert(self, value: int, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MVectorArray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, src: MVectorArray, /) -> None: ...
    @overload
    def __init__(self, size: int, value: MVector, /) -> None: ...
    @overload
    def __init__(self, seq: Sequence[MVector], /) -> None: ...
    def __add__(self, value: list[MVector], /) -> MVectorArray: ...
    def __contains__(self, key: MVector, /) -> bool: ...
    def __delitem__(
        self,
        key: SupportsIndex
        | slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        /,
    ) -> None: ...
    def __getitem__(self, i: SupportsIndex, /) -> MVector: ...
    def __iadd__(self, value: Iterable[MVector], /) -> Self: ...
    def __imul__(self, value: SupportsIndex, /) -> Self: ...
    def __len__(self) -> int: ...
    def __mul__(self, value: SupportsIndex, /) -> MVectorArray: ...
    def __rmul__(self, value: SupportsIndex, /) -> MVectorArray: ...
    def __setitem__(
        self,
        key: slice[SupportsIndex | None, SupportsIndex | None, SupportsIndex | None],
        value: Iterable[MVector],
        /,
    ) -> None: ...
    def append(self, value: MVector, /) -> None: ...
    def clear(self) -> None: ...
    def copy(self, src: MVectorArray | Sequence[MVector], /) -> None: ...
    def insert(self, value: MVector, index: int, /) -> None: ...
    def remove(self, index: int, /) -> None: ...
    def setLength(self, newSize: int, /) -> None: ...
    @property
    def sizeIncrement(self) -> int: ...
    @sizeIncrement.setter
    def sizeIncrement(self, value: int) -> None: ...

class MFn:
    kACos: Literal[1160]
    kAISEnvFacade: Literal[978]
    kASin: Literal[1162]
    kATan: Literal[1163]
    kATan2: Literal[1164]
    kAbsolute: Literal[1159]
    kAddDoubleLinear: Literal[5]
    kAdskMaterial: Literal[1068]
    kAffect: Literal[6]
    kAimConstraint: Literal[111]
    kAimMatrix: Literal[1140]
    kAir: Literal[257]
    kAlignCurve: Literal[41]
    kAlignManip: Literal[913]
    kAlignSurface: Literal[42]
    kAmbientLight: Literal[303]
    kAnd: Literal[1161]
    kAngle: Literal[270]
    kAngleBetween: Literal[21]
    kAngleToDoubleNode: Literal[1157]
    kAnimBlend: Literal[795]
    kAnimBlendInOut: Literal[796]
    kAnimCurve: Literal[7]
    kAnimCurveTimeToAngular: Literal[8]
    kAnimCurveTimeToDistance: Literal[9]
    kAnimCurveTimeToTime: Literal[10]
    kAnimCurveTimeToUnitless: Literal[11]
    kAnimCurveUnitlessToAngular: Literal[12]
    kAnimCurveUnitlessToDistance: Literal[13]
    kAnimCurveUnitlessToTime: Literal[14]
    kAnimCurveUnitlessToUnitless: Literal[15]
    kAnimLayer: Literal[1021]
    kAnisotropy: Literal[623]
    kAnnotation: Literal[271]
    kAnyGeometryVarGroup: Literal[115]
    kArcLength: Literal[273]
    kAreaLight: Literal[305]
    kArrayMapper: Literal[528]
    kArrowManip: Literal[123]
    kArubaTesselate: Literal[1133]
    kAssembly: Literal[1082]
    kAsset: Literal[1019]
    kAttachCurve: Literal[43]
    kAttachSurface: Literal[44]
    kAttribute: Literal[565]
    kAttribute2Double: Literal[748]
    kAttribute2Float: Literal[749]
    kAttribute2Int: Literal[751]
    kAttribute2Short: Literal[750]
    kAttribute3Double: Literal[752]
    kAttribute3Float: Literal[753]
    kAttribute3Int: Literal[755]
    kAttribute3Short: Literal[754]
    kAttribute4Double: Literal[881]
    kAudio: Literal[22]
    kAverage: Literal[1165]
    kAverageCurveManip: Literal[149]
    kAvgCurves: Literal[45]
    kAvgNurbsSurfacePoints: Literal[47]
    kAvgSurfacePoints: Literal[46]
    kAxesActionManip: Literal[124]
    kAxisFromMatrix: Literal[1199]
    kBackground: Literal[23]
    kBallProjectionManip: Literal[125]
    kBarnDoorManip: Literal[150]
    kBase: Literal[1]
    kBaseLattice: Literal[249]
    kBendLattice: Literal[335]
    kBevel: Literal[48]
    kBevelManip: Literal[151]
    kBevelPlus: Literal[900]
    kBezierCurve: Literal[1055]
    kBezierCurveData: Literal[1056]
    kBezierCurveToNurbs: Literal[1058]
    kBinaryData: Literal[747]
    kBirailSrf: Literal[49]
    kBlend: Literal[27]
    kBlendColorSet: Literal[740]
    kBlendColors: Literal[31]
    kBlendDevice: Literal[30]
    kBlendFalloff: Literal[1142]
    kBlendManip: Literal[152]
    kBlendMatrix: Literal[1138]
    kBlendNodeAdditiveRotation: Literal[1034]
    kBlendNodeAdditiveScale: Literal[1033]
    kBlendNodeBase: Literal[1022]
    kBlendNodeBoolean: Literal[1023]
    kBlendNodeDouble: Literal[1024]
    kBlendNodeDoubleAngle: Literal[1025]
    kBlendNodeDoubleLinear: Literal[1026]
    kBlendNodeEnum: Literal[1027]
    kBlendNodeFloat: Literal[1028]
    kBlendNodeFloatAngle: Literal[1029]
    kBlendNodeFloatLinear: Literal[1030]
    kBlendNodeInt16: Literal[1031]
    kBlendNodeInt32: Literal[1032]
    kBlendNodeTime: Literal[1053]
    kBlendShape: Literal[336]
    kBlendTwoAttr: Literal[28]
    kBlendWeighted: Literal[29]
    kBlindData: Literal[757]
    kBlindDataTemplate: Literal[758]
    kBlinn: Literal[373]
    kBlinnMaterial: Literal[389]
    kBoundary: Literal[53]
    kBox: Literal[868]
    kBoxData: Literal[867]
    kBrownian: Literal[508]
    kBrush: Literal[766]
    kBulge: Literal[497]
    kBulgeLattice: Literal[338]
    kBump: Literal[32]
    kBump3d: Literal[33]
    kButtonManip: Literal[153]
    kCacheBase: Literal[1000]
    kCacheBlend: Literal[1001]
    kCacheFile: Literal[988]
    kCacheTrack: Literal[1002]
    kCacheableNode: Literal[997]
    kCaddyManipBase: Literal[1111]
    kCamera: Literal[250]
    kCameraManip: Literal[154]
    kCameraPlaneManip: Literal[143]
    kCameraSet: Literal[1012]
    kCameraView: Literal[34]
    kCeil: Literal[1166]
    kCenterManip: Literal[134]
    kChainToSpline: Literal[35]
    kCharacter: Literal[689]
    kCharacterMap: Literal[804]
    kCharacterMappingData: Literal[743]
    kCharacterOffset: Literal[690]
    kChecker: Literal[498]
    kChoice: Literal[36]
    kChooser: Literal[773]
    kCircle: Literal[54]
    kCircleManip: Literal[126]
    kCirclePointManip: Literal[231]
    kCircleSweepManip: Literal[128]
    kClampColor: Literal[39]
    kClampRange: Literal[1167]
    kClientDevice: Literal[1078]
    kClip: Literal[810]
    kClipGhostShape: Literal[1083]
    kClipLibrary: Literal[781]
    kClipScheduler: Literal[780]
    kClipToGhostData: Literal[1084]
    kCloseCurve: Literal[55]
    kCloseSurface: Literal[57]
    kClosestPointOnMesh: Literal[990]
    kClosestPointOnSurface: Literal[56]
    kCloth: Literal[499]
    kCloud: Literal[509]
    kCluster: Literal[251]
    kClusterFilter: Literal[347]
    kClusterFlexor: Literal[300]
    kCoiManip: Literal[155]
    kCollision: Literal[253]
    kColorBackground: Literal[24]
    kColorMgtGlobals: Literal[1102]
    kColorProfile: Literal[1067]
    kColumnFromMatrix: Literal[1204]
    kCombinationShape: Literal[337]
    kCommCornerManip: Literal[614]
    kCommCornerOperManip: Literal[615]
    kCommEdgeOperManip: Literal[612]
    kCommEdgePtManip: Literal[611]
    kCommEdgeSegmentManip: Literal[613]
    kComponent: Literal[535]
    kComponentFalloff: Literal[1145]
    kComponentListData: Literal[584]
    kComponentManip: Literal[675]
    kComponentMatch: Literal[1150]
    kComposeMatrix: Literal[1137]
    kCompoundAttribute: Literal[575]
    kConcentricProjectionManip: Literal[129]
    kCondition: Literal[37]
    kCone: Literal[96]
    kConstraint: Literal[933]
    kContainer: Literal[1014]
    kContainerBase: Literal[1069]
    kContourProjectionManip: Literal[1116]
    kContrast: Literal[38]
    kControl: Literal[486]
    kControllerTag: Literal[1129]
    kCopyColorSet: Literal[739]
    kCopyUVSet: Literal[808]
    kCos: Literal[1168]
    kCpManip: Literal[156]
    kCrater: Literal[510]
    kCreaseSet: Literal[1091]
    kCreate: Literal[40]
    kCreateBPManip: Literal[838]
    kCreateBezierManip: Literal[1054]
    kCreateCVManip: Literal[157]
    kCreateColorSet: Literal[737]
    kCreateEPManip: Literal[158]
    kCreateSectionManip: Literal[825]
    kCreateUVSet: Literal[809]
    kCrossProduct: Literal[1196]
    kCrossSectionEditManip: Literal[826]
    kCrossSectionManager: Literal[824]
    kCubicProjectionManip: Literal[130]
    kCurve: Literal[266]
    kCurveCVComponent: Literal[536]
    kCurveCurveIntersect: Literal[642]
    kCurveEPComponent: Literal[537]
    kCurveEdManip: Literal[159]
    kCurveFromMeshCoM: Literal[935]
    kCurveFromMeshEdge: Literal[641]
    kCurveFromSubdivEdge: Literal[837]
    kCurveFromSubdivFace: Literal[843]
    kCurveFromSurface: Literal[58]
    kCurveFromSurfaceBnd: Literal[59]
    kCurveFromSurfaceCoS: Literal[60]
    kCurveFromSurfaceIso: Literal[61]
    kCurveInfo: Literal[62]
    kCurveKnotComponent: Literal[538]
    kCurveNormalizerAngle: Literal[1004]
    kCurveNormalizerLinear: Literal[1005]
    kCurveParamComponent: Literal[539]
    kCurveSegmentManip: Literal[160]
    kCurveVarGroup: Literal[116]
    kCustomEvaluatorClusterNode: Literal[1131]
    kCylinder: Literal[98]
    kCylindricalProjectionManip: Literal[131]
    kDOF: Literal[323]
    kDPbirailSrf: Literal[50]
    kDagContainer: Literal[1070]
    kDagNode: Literal[107]
    kDagPose: Literal[691]
    kDagSelectionItem: Literal[562]
    kData: Literal[583]
    kData2Double: Literal[594]
    kData2Float: Literal[595]
    kData2Int: Literal[596]
    kData2Short: Literal[597]
    kData3Double: Literal[598]
    kData3Float: Literal[599]
    kData3Int: Literal[600]
    kData3Short: Literal[601]
    kData4Double: Literal[882]
    kDblTrsManip: Literal[190]
    kDecayRegionCapComponent: Literal[548]
    kDecayRegionComponent: Literal[549]
    kDecomposeMatrix: Literal[1136]
    kDefaultLightList: Literal[317]
    kDeformBend: Literal[626]
    kDeformBendManip: Literal[632]
    kDeformFlare: Literal[629]
    kDeformFlareManip: Literal[635]
    kDeformFunc: Literal[625]
    kDeformSine: Literal[630]
    kDeformSineManip: Literal[636]
    kDeformSquash: Literal[628]
    kDeformSquashManip: Literal[634]
    kDeformTwist: Literal[627]
    kDeformTwistManip: Literal[633]
    kDeformWave: Literal[631]
    kDeformWaveManip: Literal[637]
    kDeleteColorSet: Literal[738]
    kDeleteComponent: Literal[318]
    kDeleteUVSet: Literal[801]
    kDeltaMush: Literal[350]
    kDependencyNode: Literal[4]
    kDetachCurve: Literal[63]
    kDetachSurface: Literal[64]
    kDeterminant: Literal[1169]
    kDiffuseMaterial: Literal[387]
    kDimension: Literal[269]
    kDimensionManip: Literal[232]
    kDirectedDisc: Literal[276]
    kDirectionManip: Literal[161]
    kDirectionalLight: Literal[308]
    kDiscManip: Literal[132]
    kDiskCache: Literal[864]
    kDispatchCompute: Literal[319]
    kDisplacementShader: Literal[321]
    kDisplayLayer: Literal[734]
    kDisplayLayerManager: Literal[735]
    kDistance: Literal[272]
    kDistanceBetween: Literal[322]
    kDistanceManip: Literal[639]
    kDivide: Literal[1200]
    kDofManip: Literal[162]
    kDotProduct: Literal[1195]
    kDoubleAngleAttribute: Literal[567]
    kDoubleArrayData: Literal[585]
    kDoubleIndexedComponent: Literal[715]
    kDoubleLinearAttribute: Literal[569]
    kDoubleShadingSwitch: Literal[620]
    kDoubleToAngleNode: Literal[1158]
    kDrag: Literal[258]
    kDropOffFunction: Literal[827]
    kDropoffLocator: Literal[282]
    kDropoffManip: Literal[163]
    kDummy: Literal[254]
    kDummyConnectable: Literal[324]
    kDynAirManip: Literal[725]
    kDynArrayAttrsData: Literal[730]
    kDynAttenuationManip: Literal[729]
    kDynBase: Literal[721]
    kDynBaseFieldManip: Literal[724]
    kDynEmitterManip: Literal[722]
    kDynFieldsManip: Literal[723]
    kDynGlobals: Literal[770]
    kDynNewtonManip: Literal[726]
    kDynParticleSetComponent: Literal[560]
    kDynSpreadManip: Literal[728]
    kDynSweptGeometryData: Literal[744]
    kDynTurbulenceManip: Literal[727]
    kDynamicConstraint: Literal[994]
    kDynamicsController: Literal[325]
    kEdgeComponent: Literal[545]
    kEditCurve: Literal[822]
    kEditCurveManip: Literal[823]
    kEditMetadata: Literal[1090]
    kEditsManager: Literal[1098]
    kEmitter: Literal[255]
    kEnableManip: Literal[136]
    kEnumAttribute: Literal[572]
    kEnvBall: Literal[491]
    kEnvChrome: Literal[493]
    kEnvCube: Literal[492]
    kEnvFacade: Literal[977]
    kEnvFogMaterial: Literal[381]
    kEnvFogShape: Literal[278]
    kEnvSky: Literal[494]
    kEnvSphere: Literal[495]
    kEqual: Literal[1170]
    kExplodeNurbsShell: Literal[693]
    kExpression: Literal[327]
    kExtendCurve: Literal[65]
    kExtendCurveDistanceManip: Literal[164]
    kExtendSurface: Literal[66]
    kExtendSurfaceDistanceManip: Literal[717]
    kExtract: Literal[328]
    kExtrude: Literal[67]
    kExtrudeManip: Literal[165]
    kFFD: Literal[339]
    kFFblendSrf: Literal[68]
    kFFfilletSrf: Literal[69]
    kFacade: Literal[975]
    kFalloffEval: Literal[1149]
    kFfdDualBase: Literal[340]
    kField: Literal[256]
    kFileBackground: Literal[25]
    kFileTexture: Literal[500]
    kFilletCurve: Literal[70]
    kFilter: Literal[329]
    kFilterClosestSample: Literal[330]
    kFilterEuler: Literal[331]
    kFilterSimplify: Literal[332]
    kFitBspline: Literal[71]
    kFixedLineManip: Literal[233]
    kFlexor: Literal[299]
    kFloatAngleAttribute: Literal[568]
    kFloatArrayData: Literal[1038]
    kFloatLinearAttribute: Literal[570]
    kFloatMatrixAttribute: Literal[579]
    kFloatVectorArrayData: Literal[1015]
    kFloor: Literal[1171]
    kFlow: Literal[72]
    kFluid: Literal[915]
    kFluidData: Literal[917]
    kFluidEmitter: Literal[921]
    kFluidGeom: Literal[916]
    kFluidTexture2D: Literal[910]
    kFluidTexture3D: Literal[909]
    kFollicle: Literal[936]
    kForceUpdateManip: Literal[696]
    kFosterParent: Literal[1093]
    kFourByFourMatrix: Literal[776]
    kFractal: Literal[501]
    kFreePointManip: Literal[133]
    kFreePointTriadManip: Literal[137]
    kGammaCorrect: Literal[333]
    kGenericAttribute: Literal[576]
    kGeoConnectable: Literal[326]
    kGeoConnector: Literal[923]
    kGeomBind: Literal[1101]
    kGeometric: Literal[265]
    kGeometryConstraint: Literal[113]
    kGeometryData: Literal[713]
    kGeometryFilt: Literal[334]
    kGeometryOnLineManip: Literal[142]
    kGeometryVarGroup: Literal[114]
    kGlobalCacheControls: Literal[863]
    kGlobalStitch: Literal[702]
    kGranite: Literal[511]
    kGravity: Literal[259]
    kGreasePencilSequence: Literal[1089]
    kGreasePlane: Literal[1087]
    kGreasePlaneRenderShape: Literal[1088]
    kGreaterThan: Literal[1172]
    kGrid: Literal[502]
    kGroundPlane: Literal[290]
    kGroupId: Literal[356]
    kGroupParts: Literal[357]
    kGuide: Literal[358]
    kGuideLine: Literal[301]
    kHairConstraint: Literal[941]
    kHairSystem: Literal[937]
    kHairTubeShader: Literal[948]
    kHandleRotateManip: Literal[216]
    kHardenPointCurve: Literal[73]
    kHardwareReflectionMap: Literal[887]
    kHardwareRenderGlobals: Literal[527]
    kHardwareRenderingGlobals: Literal[1072]
    kHeightField: Literal[922]
    kHikEffector: Literal[962]
    kHikFKJoint: Literal[964]
    kHikFloorContactMarker: Literal[984]
    kHikGroundPlane: Literal[985]
    kHikHandle: Literal[966]
    kHikIKEffector: Literal[963]
    kHikSolver: Literal[965]
    kHistorySwitch: Literal[989]
    kHsvToRgb: Literal[359]
    kHwShaderNode: Literal[890]
    kHyperGraphInfo: Literal[360]
    kHyperLayout: Literal[361]
    kHyperLayoutDG: Literal[1006]
    kHyperView: Literal[362]
    kIkEffector: Literal[119]
    kIkHandle: Literal[120]
    kIkRPManip: Literal[167]
    kIkSolver: Literal[363]
    kIkSplineManip: Literal[166]
    kIkSystem: Literal[369]
    kIllustratorCurve: Literal[74]
    kImageAdd: Literal[660]
    kImageBlur: Literal[666]
    kImageColorCorrect: Literal[665]
    kImageData: Literal[654]
    kImageDepth: Literal[668]
    kImageDiff: Literal[661]
    kImageDisplay: Literal[669]
    kImageFilter: Literal[667]
    kImageLoad: Literal[655]
    kImageMotionBlur: Literal[671]
    kImageMultiply: Literal[662]
    kImageNetDest: Literal[658]
    kImageNetSrc: Literal[657]
    kImageOver: Literal[663]
    kImagePlane: Literal[370]
    kImageRender: Literal[659]
    kImageSave: Literal[656]
    kImageSource: Literal[792]
    kImageUnder: Literal[664]
    kImageView: Literal[670]
    kImplicitCone: Literal[895]
    kImplicitSphere: Literal[896]
    kInsertKnotCrv: Literal[75]
    kInsertKnotSrf: Literal[76]
    kInstancer: Literal[763]
    kInt64ArrayData: Literal[815]
    kIntArrayData: Literal[586]
    kIntersectSurface: Literal[77]
    kInvalid: Literal[0]
    kInverseLinearInterpolation: Literal[1173]
    kIsoparmComponent: Literal[540]
    kIsoparmManip: Literal[146]
    kItemList: Literal[564]
    kJiggleDeformer: Literal[862]
    kJoint: Literal[121]
    kJointCluster: Literal[349]
    kJointClusterManip: Literal[168]
    kJointTranslateManip: Literal[229]
    kKeyframeDelta: Literal[950]
    kKeyframeDeltaAddRemove: Literal[953]
    kKeyframeDeltaBlockAddRemove: Literal[954]
    kKeyframeDeltaBreakdown: Literal[958]
    kKeyframeDeltaInfType: Literal[955]
    kKeyframeDeltaMove: Literal[951]
    kKeyframeDeltaScale: Literal[952]
    kKeyframeDeltaTangent: Literal[956]
    kKeyframeDeltaWeighted: Literal[957]
    kKeyframeRegionManip: Literal[1003]
    kKeyingGroup: Literal[688]
    kLambert: Literal[371]
    kLambertMaterial: Literal[388]
    kLattice: Literal[279]
    kLatticeComponent: Literal[546]
    kLatticeData: Literal[588]
    kLatticeGeom: Literal[280]
    kLayeredShader: Literal[376]
    kLayeredTexture: Literal[805]
    kLeastSquares: Literal[379]
    kLeather: Literal[512]
    kLength: Literal[1174]
    kLessThan: Literal[1175]
    kLight: Literal[302]
    kLightDataAttribute: Literal[577]
    kLightFogMaterial: Literal[380]
    kLightInfo: Literal[378]
    kLightLink: Literal[769]
    kLightList: Literal[382]
    kLightManip: Literal[169]
    kLightProjectionGeometry: Literal[234]
    kLightSource: Literal[383]
    kLightSourceMaterial: Literal[391]
    kLimitManip: Literal[135]
    kLineArrowManip: Literal[235]
    kLineManip: Literal[147]
    kLineModifier: Literal[979]
    kLinearInterpolation: Literal[1176]
    kLinearLight: Literal[306]
    kLocator: Literal[281]
    kLodGroup: Literal[774]
    kLodThresholds: Literal[772]
    kLog: Literal[1177]
    kLookAt: Literal[112]
    kLuminance: Literal[384]
    kMCsolver: Literal[364]
    kMPbirailSrf: Literal[51]
    kMakeGroup: Literal[385]
    kMandelbrot: Literal[1085]
    kMandelbrot3D: Literal[1086]
    kManip2DContainer: Literal[192]
    kManipContainer: Literal[148]
    kManipulator: Literal[230]
    kManipulator2D: Literal[205]
    kManipulator3D: Literal[122]
    kMarble: Literal[513]
    kMarker: Literal[283]
    kMarkerManip: Literal[210]
    kMaterial: Literal[386]
    kMaterialFacade: Literal[976]
    kMaterialInfo: Literal[392]
    kMaterialTemplate: Literal[393]
    kMatrixAdd: Literal[394]
    kMatrixArrayData: Literal[604]
    kMatrixAttribute: Literal[578]
    kMatrixData: Literal[589]
    kMatrixFloatData: Literal[673]
    kMatrixHold: Literal[395]
    kMatrixMult: Literal[396]
    kMatrixPass: Literal[397]
    kMatrixWtAdd: Literal[398]
    kMax: Literal[1178]
    kMembrane: Literal[1039]
    kMergeVertsToolManip: Literal[1040]
    kMesh: Literal[296]
    kMeshComponent: Literal[550]
    kMeshData: Literal[590]
    kMeshEdgeComponent: Literal[551]
    kMeshFaceVertComponent: Literal[555]
    kMeshFrEdgeComponent: Literal[553]
    kMeshGeom: Literal[297]
    kMeshMapComponent: Literal[818]
    kMeshPolygonComponent: Literal[552]
    kMeshVarGroup: Literal[117]
    kMeshVertComponent: Literal[554]
    kMeshVtxFaceComponent: Literal[746]
    kMessageAttribute: Literal[580]
    kMidModifier: Literal[399]
    kMidModifierWithMatrix: Literal[400]
    kMin: Literal[1179]
    kModel: Literal[3]
    kModifyEdgeBaseManip: Literal[839]
    kModifyEdgeCrvManip: Literal[830]
    kModifyEdgeManip: Literal[831]
    kModulo: Literal[1180]
    kMorph: Literal[352]
    kMotionPath: Literal[445]
    kMotionPathManip: Literal[170]
    kMountain: Literal[503]
    kMoveUVShellManip2D: Literal[711]
    kMoveVertexManip: Literal[764]
    kMultDoubleLinear: Literal[775]
    kMultiSubVertexComponent: Literal[558]
    kMultilisterLight: Literal[447]
    kMultiply: Literal[1181]
    kMultiplyDivide: Literal[448]
    kMultiplyPointByMatrix: Literal[1197]
    kMultiplyVectorByMatrix: Literal[1198]
    kMute: Literal[932]
    kNBase: Literal[999]
    kNCloth: Literal[1008]
    kNComponent: Literal[995]
    kNId: Literal[1037]
    kNIdData: Literal[1036]
    kNLE: Literal[1096]
    kNObject: Literal[1017]
    kNObjectData: Literal[1016]
    kNParticle: Literal[1009]
    kNRigid: Literal[1010]
    kNamedObject: Literal[2]
    kNearestPointOnCurve: Literal[1066]
    kNegate: Literal[1182]
    kNewton: Literal[260]
    kNodeGraphEditorBookmarkInfo: Literal[1119]
    kNodeGraphEditorBookmarks: Literal[1118]
    kNodeGraphEditorInfo: Literal[1117]
    kNoise: Literal[880]
    kNonAmbientLight: Literal[304]
    kNonDagSelectionItem: Literal[563]
    kNonExtendedLight: Literal[307]
    kNonLinear: Literal[624]
    kNormalConstraint: Literal[238]
    kNormalize: Literal[1183]
    kNot: Literal[1184]
    kNucleus: Literal[998]
    kNumericAttribute: Literal[566]
    kNumericData: Literal[593]
    kNurbsBoolean: Literal[694]
    kNurbsCircular2PtArc: Literal[644]
    kNurbsCircular3PtArc: Literal[643]
    kNurbsCube: Literal[80]
    kNurbsCurve: Literal[267]
    kNurbsCurveData: Literal[592]
    kNurbsCurveGeom: Literal[268]
    kNurbsCurveToBezier: Literal[1057]
    kNurbsPlane: Literal[79]
    kNurbsSquare: Literal[622]
    kNurbsSurface: Literal[294]
    kNurbsSurfaceData: Literal[591]
    kNurbsSurfaceGeom: Literal[295]
    kNurbsTesselate: Literal[78]
    kNurbsToSubdiv: Literal[761]
    kObjectAttrFilter: Literal[681]
    kObjectBinFilter: Literal[944]
    kObjectFilter: Literal[677]
    kObjectMultiFilter: Literal[678]
    kObjectNameFilter: Literal[679]
    kObjectRenderFilter: Literal[682]
    kObjectScriptFilter: Literal[683]
    kObjectTypeFilter: Literal[680]
    kOcean: Literal[876]
    kOceanDeformer: Literal[1127]
    kOceanShader: Literal[899]
    kOffsetCos: Literal[81]
    kOffsetCosManip: Literal[171]
    kOffsetCurve: Literal[82]
    kOffsetCurveManip: Literal[172]
    kOffsetSurface: Literal[645]
    kOffsetSurfaceManip: Literal[653]
    kOldGeometryConstraint: Literal[449]
    kOpaqueAttribute: Literal[581]
    kOpenPBRSurface: Literal[1209]
    kOpticalFX: Literal[450]
    kOr: Literal[1185]
    kOrientConstraint: Literal[239]
    kOrientationComponent: Literal[556]
    kOrientationLocator: Literal[286]
    kOrientationMarker: Literal[284]
    kOrthoGrid: Literal[291]
    kPASolver: Literal[365]
    kPIConstant: Literal[1186]
    kPairBlend: Literal[928]
    kParamDimension: Literal[275]
    kParentConstraint: Literal[242]
    kParentMatrix: Literal[1207]
    kParticle: Literal[311]
    kParticleAgeMapper: Literal[451]
    kParticleCloud: Literal[452]
    kParticleColorMapper: Literal[453]
    kParticleIncandecenceMapper: Literal[454]
    kParticleSamplerInfo: Literal[807]
    kParticleTransparencyMapper: Literal[455]
    kPartition: Literal[456]
    kPassContributionMap: Literal[788]
    kPfxGeometry: Literal[946]
    kPfxHair: Literal[947]
    kPfxToon: Literal[972]
    kPhong: Literal[374]
    kPhongExplorer: Literal[375]
    kPhongMaterial: Literal[390]
    kPickMatrix: Literal[1139]
    kPivotComponent: Literal[541]
    kPivotManip2D: Literal[191]
    kPlace2dTexture: Literal[457]
    kPlace3dTexture: Literal[458]
    kPlanarProjectionManip: Literal[207]
    kPlanarTrimSrf: Literal[83]
    kPlane: Literal[288]
    kPlugin: Literal[582]
    kPluginBlendShape: Literal[1122]
    kPluginCameraSet: Literal[1013]
    kPluginClientDevice: Literal[1079]
    kPluginConstraintNode: Literal[1018]
    kPluginData: Literal[602]
    kPluginDeformerNode: Literal[616]
    kPluginDependNode: Literal[459]
    kPluginEmitterNode: Literal[732]
    kPluginFieldNode: Literal[731]
    kPluginGeometryData: Literal[768]
    kPluginGeometryFilter: Literal[1121]
    kPluginHardwareShader: Literal[891]
    kPluginHwShaderNode: Literal[892]
    kPluginIkSolver: Literal[762]
    kPluginImagePlaneNode: Literal[1007]
    kPluginLocatorNode: Literal[460]
    kPluginManipContainer: Literal[697]
    kPluginManipulatorNode: Literal[1035]
    kPluginMotionPathNode: Literal[446]
    kPluginObjectSet: Literal[925]
    kPluginParticleAttributeMapperNode: Literal[1011]
    kPluginShape: Literal[712]
    kPluginSkinCluster: Literal[1120]
    kPluginSpringNode: Literal[733]
    kPluginThreadedDevice: Literal[1080]
    kPluginTransformNode: Literal[914]
    kPlusMinusAverage: Literal[461]
    kPointArrayData: Literal[603]
    kPointConstraint: Literal[240]
    kPointLight: Literal[309]
    kPointManip: Literal[236]
    kPointMatrixMult: Literal[462]
    kPointOnCurveInfo: Literal[84]
    kPointOnCurveManip: Literal[208]
    kPointOnLineManip: Literal[211]
    kPointOnPolyConstraint: Literal[1061]
    kPointOnSurfaceInfo: Literal[85]
    kPointOnSurfaceManip: Literal[212]
    kPoleVectorConstraint: Literal[243]
    kPolyAppend: Literal[403]
    kPolyAppendVertex: Literal[797]
    kPolyArrow: Literal[980]
    kPolyAutoProj: Literal[852]
    kPolyAutoProjManip: Literal[968]
    kPolyAverageVertex: Literal[851]
    kPolyAxis: Literal[1156]
    kPolyBevel: Literal[401]
    kPolyBevel2: Literal[1099]
    kPolyBevel3: Literal[1103]
    kPolyBevelCutback: Literal[1208]
    kPolyBlindData: Literal[759]
    kPolyBoolOp: Literal[618]
    kPolyBridgeEdge: Literal[996]
    kPolyCBoolOp: Literal[1100]
    kPolyCaddyManip: Literal[1112]
    kPolyChipOff: Literal[404]
    kPolyCircularize: Literal[1132]
    kPolyClean: Literal[1125]
    kPolyCloseBorder: Literal[405]
    kPolyCollapseEdge: Literal[406]
    kPolyCollapseF: Literal[407]
    kPolyColorDel: Literal[742]
    kPolyColorMod: Literal[741]
    kPolyColorPerVertex: Literal[736]
    kPolyComponentData: Literal[986]
    kPolyCone: Literal[437]
    kPolyConnectComponents: Literal[1062]
    kPolyContourProj: Literal[1115]
    kPolyCreaseEdge: Literal[960]
    kPolyCreateFacet: Literal[443]
    kPolyCreateToolManip: Literal[140]
    kPolyCreator: Literal[435]
    kPolyCube: Literal[438]
    kPolyCut: Literal[902]
    kPolyCutManip: Literal[906]
    kPolyCutManipContainer: Literal[905]
    kPolyCylProj: Literal[408]
    kPolyCylinder: Literal[439]
    kPolyDelEdge: Literal[409]
    kPolyDelFacet: Literal[410]
    kPolyDelVertex: Literal[411]
    kPolyDuplicateEdge: Literal[974]
    kPolyEdgeToCurve: Literal[1020]
    kPolyEditEdgeFlow: Literal[1092]
    kPolyExtrudeEdge: Literal[794]
    kPolyExtrudeFacet: Literal[412]
    kPolyExtrudeManip: Literal[1075]
    kPolyExtrudeManipContainer: Literal[1076]
    kPolyExtrudeVertex: Literal[927]
    kPolyFlipEdge: Literal[793]
    kPolyFlipUV: Literal[889]
    kPolyHelix: Literal[987]
    kPolyHoleFace: Literal[1060]
    kPolyLayoutUV: Literal[853]
    kPolyMapCut: Literal[413]
    kPolyMapDel: Literal[414]
    kPolyMapSew: Literal[415]
    kPolyMapSewMove: Literal[854]
    kPolyMappingManip: Literal[194]
    kPolyMergeEdge: Literal[416]
    kPolyMergeFacet: Literal[417]
    kPolyMergeUV: Literal[911]
    kPolyMergeVert: Literal[699]
    kPolyMesh: Literal[440]
    kPolyMirror: Literal[959]
    kPolyMirrorManipContainer: Literal[907]
    kPolyModifierManip: Literal[195]
    kPolyModifierManipContainer: Literal[1113]
    kPolyMoveEdge: Literal[418]
    kPolyMoveFacet: Literal[419]
    kPolyMoveFacetUV: Literal[420]
    kPolyMoveUV: Literal[421]
    kPolyMoveUVManip: Literal[193]
    kPolyMoveVertex: Literal[422]
    kPolyMoveVertexManip: Literal[196]
    kPolyMoveVertexUV: Literal[423]
    kPolyNormal: Literal[424]
    kPolyNormalPerVertex: Literal[760]
    kPolyNormalizeUV: Literal[888]
    kPolyPassThru: Literal[1123]
    kPolyPinUV: Literal[961]
    kPolyPipe: Literal[983]
    kPolyPlanProj: Literal[425]
    kPolyPlatonicSolid: Literal[982]
    kPolyPoke: Literal[903]
    kPolyPokeManip: Literal[908]
    kPolyPrimitive: Literal[436]
    kPolyPrimitiveMisc: Literal[981]
    kPolyPrism: Literal[969]
    kPolyProj: Literal[426]
    kPolyProjectCurve: Literal[1073]
    kPolyProjectionManip: Literal[174]
    kPolyPyramid: Literal[970]
    kPolyQuad: Literal[427]
    kPolyReFormManip: Literal[1155]
    kPolyReFormManipContainer: Literal[1154]
    kPolyReduce: Literal[771]
    kPolyRemesh: Literal[1114]
    kPolySelectEditFeedbackManip: Literal[1043]
    kPolySeparate: Literal[463]
    kPolySewEdge: Literal[698]
    kPolySmartExtrude: Literal[1152]
    kPolySmartExtrudeManip: Literal[1153]
    kPolySmooth: Literal[428]
    kPolySmoothFacet: Literal[700]
    kPolySmoothProxy: Literal[945]
    kPolySoftEdge: Literal[429]
    kPolySphProj: Literal[430]
    kPolySphere: Literal[441]
    kPolySpinEdge: Literal[1059]
    kPolySplit: Literal[431]
    kPolySplitEdge: Literal[816]
    kPolySplitRing: Literal[971]
    kPolySplitToolManip: Literal[141]
    kPolySplitVert: Literal[811]
    kPolyStraightenUVBorder: Literal[912]
    kPolySubdEdge: Literal[432]
    kPolySubdFacet: Literal[433]
    kPolyToSubdiv: Literal[686]
    kPolyToolFeedbackManip: Literal[1042]
    kPolyToolFeedbackShape: Literal[312]
    kPolyTorus: Literal[442]
    kPolyTransfer: Literal[850]
    kPolyTriangulate: Literal[434]
    kPolyTweak: Literal[402]
    kPolyTweakUV: Literal[710]
    kPolyUVRectangle: Literal[1071]
    kPolyUnite: Literal[444]
    kPolyUnsmooth: Literal[1151]
    kPolyVertexNormalManip: Literal[197]
    kPolyWedgeFace: Literal[904]
    kPoseInterpolatorManager: Literal[1128]
    kPositionMarker: Literal[285]
    kPostProcessList: Literal[464]
    kPower: Literal[1187]
    kPrecompExport: Literal[789]
    kPrimitive: Literal[86]
    kPrimitiveFalloff: Literal[1141]
    kProjectCurve: Literal[87]
    kProjectTangent: Literal[88]
    kProjectTangentManip: Literal[177]
    kProjection: Literal[465]
    kProjectionManip: Literal[173]
    kProjectionMultiManip: Literal[176]
    kProjectionUVManip: Literal[175]
    kPropModManip: Literal[178]
    kPropMoveTriadManip: Literal[138]
    kProximityFalloff: Literal[1146]
    kProximityPin: Literal[992]
    kProximityWrap: Literal[354]
    kProxy: Literal[108]
    kProxyManager: Literal[967]
    kPsdFileTexture: Literal[949]
    kQuadPtOnLineManip: Literal[179]
    kQuadShadingSwitch: Literal[926]
    kRBFsurface: Literal[89]
    kRPsolver: Literal[367]
    kRadial: Literal[261]
    kRadius: Literal[274]
    kRamp: Literal[504]
    kRampBackground: Literal[26]
    kRampShader: Literal[897]
    kRbfSrfManip: Literal[180]
    kReForm: Literal[1130]
    kRebuildCurve: Literal[90]
    kRebuildSurface: Literal[91]
    kRecord: Literal[466]
    kReference: Literal[756]
    kReflect: Literal[372]
    kRemapColor: Literal[939]
    kRemapHsv: Literal[940]
    kRemapValue: Literal[938]
    kRenderBox: Literal[869]
    kRenderCone: Literal[97]
    kRenderGlobals: Literal[523]
    kRenderGlobalsList: Literal[524]
    kRenderLayer: Literal[786]
    kRenderLayerManager: Literal[787]
    kRenderPass: Literal[784]
    kRenderPassSet: Literal[785]
    kRenderQuality: Literal[525]
    kRenderRect: Literal[277]
    kRenderSetup: Literal[522]
    kRenderSphere: Literal[298]
    kRenderTarget: Literal[790]
    kRenderUtilityList: Literal[467]
    kRenderedImageSource: Literal[791]
    kRenderingList: Literal[1074]
    kReorderUVSet: Literal[1134]
    kResolution: Literal[526]
    kResultCurve: Literal[16]
    kResultCurveTimeToAngular: Literal[17]
    kResultCurveTimeToDistance: Literal[18]
    kResultCurveTimeToTime: Literal[19]
    kResultCurveTimeToUnitless: Literal[20]
    kReverse: Literal[468]
    kReverseCrvManip: Literal[182]
    kReverseCurve: Literal[92]
    kReverseCurveManip: Literal[181]
    kReverseSurface: Literal[93]
    kReverseSurfaceManip: Literal[183]
    kRevolve: Literal[94]
    kRevolveManip: Literal[184]
    kRevolvedPrimitive: Literal[95]
    kRevolvedPrimitiveManip: Literal[185]
    kRgbToHsv: Literal[469]
    kRigid: Literal[314]
    kRigidConstraint: Literal[313]
    kRigidDeform: Literal[341]
    kRigidSolver: Literal[470]
    kRock: Literal[514]
    kRotateBoxManip: Literal[214]
    kRotateLimitsManip: Literal[217]
    kRotateManip: Literal[215]
    kRotateUVManip2D: Literal[708]
    kRotateVector: Literal[1188]
    kRotationFromMatrix: Literal[1206]
    kRound: Literal[1189]
    kRoundConstantRadius: Literal[646]
    kRoundConstantRadiusManip: Literal[649]
    kRoundRadiusCrvManip: Literal[648]
    kRoundRadiusManip: Literal[647]
    kRowFromMatrix: Literal[1203]
    kSCsolver: Literal[366]
    kSPbirailSrf: Literal[52]
    kSamplerInfo: Literal[478]
    kScaleConstraint: Literal[244]
    kScaleFromMatrix: Literal[1205]
    kScaleLimitsManip: Literal[218]
    kScaleManip: Literal[219]
    kScalePointManip: Literal[832]
    kScaleUVManip2D: Literal[709]
    kScalingBoxManip: Literal[220]
    kScreenAlignedCircleManip: Literal[127]
    kScript: Literal[640]
    kScriptManip: Literal[221]
    kSculpt: Literal[342]
    kSectionManip: Literal[819]
    kSelectionItem: Literal[561]
    kSelectionList: Literal[609]
    kSelectionListData: Literal[676]
    kSelectionListOperator: Literal[684]
    kSequenceManager: Literal[1050]
    kSequencer: Literal[1051]
    kSet: Literal[471]
    kSetGroupComponent: Literal[559]
    kSetRange: Literal[474]
    kSfRevolveManip: Literal[842]
    kShaderGlow: Literal[475]
    kShaderList: Literal[476]
    kShadingEngine: Literal[320]
    kShadingMap: Literal[477]
    kShape: Literal[248]
    kShapeEditorManager: Literal[1126]
    kShapeFragment: Literal[479]
    kShot: Literal[1052]
    kShrinkWrapFilter: Literal[1097]
    kSimpleVolumeShader: Literal[480]
    kSin: Literal[1190]
    kSingleIndexedComponent: Literal[714]
    kSingleShadingSwitch: Literal[619]
    kSketchPlane: Literal[289]
    kSkin: Literal[100]
    kSkinBinding: Literal[1063]
    kSkinClusterFilter: Literal[687]
    kSkinShader: Literal[674]
    kSl60: Literal[481]
    kSmear: Literal[918]
    kSmoothCurve: Literal[701]
    kSmoothStep: Literal[1191]
    kSmoothTangentSrf: Literal[783]
    kSnapUVManip2D: Literal[1094]
    kSnapshot: Literal[482]
    kSnapshotPath: Literal[924]
    kSnapshotShape: Literal[860]
    kSnow: Literal[515]
    kSoftMod: Literal[252]
    kSoftModFilter: Literal[348]
    kSoftModManip: Literal[638]
    kSolidFractal: Literal[516]
    kSolidify: Literal[353]
    kSphere: Literal[99]
    kSphereData: Literal[605]
    kSphericalProjectionManip: Literal[222]
    kSplineSolver: Literal[368]
    kSpotCylinderManip: Literal[187]
    kSpotLight: Literal[310]
    kSpotManip: Literal[186]
    kSpring: Literal[315]
    kSprite: Literal[292]
    kSquareSrf: Literal[718]
    kSquareSrfManip: Literal[719]
    kStandardSurface: Literal[377]
    kStateManip: Literal[145]
    kStencil: Literal[505]
    kStereoCameraMaster: Literal[1049]
    kStitchAsNurbsShell: Literal[692]
    kStitchSrf: Literal[101]
    kStitchSrfManip: Literal[695]
    kStoryBoard: Literal[483]
    kStringArrayData: Literal[607]
    kStringData: Literal[606]
    kStringShadingSwitch: Literal[919]
    kStroke: Literal[765]
    kStrokeGlobals: Literal[767]
    kStucco: Literal[517]
    kStudioClearCoat: Literal[920]
    kStyleCurve: Literal[901]
    kSubCurve: Literal[102]
    kSubSurface: Literal[782]
    kSubVertexComponent: Literal[557]
    kSubdAddTopology: Literal[893]
    kSubdAutoProj: Literal[878]
    kSubdBlindData: Literal[803]
    kSubdBoolean: Literal[828]
    kSubdCleanTopology: Literal[894]
    kSubdCloseBorder: Literal[865]
    kSubdDelFace: Literal[859]
    kSubdExtrudeFace: Literal[840]
    kSubdHierBlind: Literal[802]
    kSubdLayoutUV: Literal[874]
    kSubdMapCut: Literal[873]
    kSubdMapSewMove: Literal[875]
    kSubdMappingManip: Literal[886]
    kSubdMergeVert: Literal[866]
    kSubdModifier: Literal[855]
    kSubdModifyEdge: Literal[829]
    kSubdMoveEdge: Literal[857]
    kSubdMoveFace: Literal[858]
    kSubdMoveVertex: Literal[856]
    kSubdPlanProj: Literal[883]
    kSubdProjectionManip: Literal[885]
    kSubdSplitFace: Literal[870]
    kSubdSubdivideFace: Literal[879]
    kSubdTweak: Literal[884]
    kSubdTweakUV: Literal[872]
    kSubdiv: Literal[685]
    kSubdivCVComponent: Literal[703]
    kSubdivCollapse: Literal[806]
    kSubdivCompId: Literal[799]
    kSubdivData: Literal[812]
    kSubdivEdgeComponent: Literal[704]
    kSubdivFaceComponent: Literal[705]
    kSubdivGeom: Literal[813]
    kSubdivMapComponent: Literal[861]
    kSubdivReverseFaces: Literal[817]
    kSubdivSurfaceVarGroup: Literal[841]
    kSubdivToNurbs: Literal[821]
    kSubdivToPoly: Literal[720]
    kSubsetFalloff: Literal[1147]
    kSubtract: Literal[1201]
    kSum: Literal[1192]
    kSummaryObject: Literal[484]
    kSuper: Literal[485]
    kSurface: Literal[293]
    kSurfaceCVComponent: Literal[542]
    kSurfaceEPComponent: Literal[543]
    kSurfaceEdManip: Literal[778]
    kSurfaceFaceComponent: Literal[779]
    kSurfaceInfo: Literal[103]
    kSurfaceKnotComponent: Literal[544]
    kSurfaceLuminance: Literal[487]
    kSurfaceRangeComponent: Literal[547]
    kSurfaceShader: Literal[488]
    kSurfaceVarGroup: Literal[118]
    kSymmetryConstraint: Literal[241]
    kSymmetryLocator: Literal[834]
    kSymmetryMapCurve: Literal[836]
    kSymmetryMapVector: Literal[835]
    kTan: Literal[1193]
    kTangentConstraint: Literal[245]
    kTension: Literal[351]
    kTexLattice: Literal[200]
    kTexLatticeDeformManip: Literal[199]
    kTexSmoothManip: Literal[201]
    kTexSmudgeUVManip: Literal[198]
    kTextButtonManip: Literal[652]
    kTextCurves: Literal[104]
    kTextManip: Literal[929]
    kTexture2d: Literal[496]
    kTexture3d: Literal[507]
    kTextureBakeSet: Literal[472]
    kTextureDeformer: Literal[343]
    kTextureDeformerHandle: Literal[344]
    kTextureEnv: Literal[490]
    kTextureList: Literal[489]
    kTextureManip3D: Literal[223]
    kThreadedDevice: Literal[1077]
    kThreePointArcManip: Literal[650]
    kTime: Literal[520]
    kTimeAttribute: Literal[571]
    kTimeEditor: Literal[1107]
    kTimeEditorAnimSource: Literal[1110]
    kTimeEditorClip: Literal[1106]
    kTimeEditorClipBase: Literal[1104]
    kTimeEditorClipEvaluator: Literal[1105]
    kTimeEditorInterpolator: Literal[1109]
    kTimeEditorTracks: Literal[1108]
    kTimeFunction: Literal[942]
    kTimeToUnitConversion: Literal[521]
    kTimeWarp: Literal[1081]
    kToggleManip: Literal[224]
    kToggleOnLineManip: Literal[144]
    kToolContext: Literal[1095]
    kToonLineAttributes: Literal[973]
    kTorus: Literal[617]
    kTowPointManip: Literal[139]
    kTowPointOnCurveManip: Literal[209]
    kTowPointOnSurfaceManip: Literal[777]
    kTrackInfoManager: Literal[1124]
    kTransferAttributes: Literal[993]
    kTransferFalloff: Literal[1144]
    kTransform: Literal[110]
    kTransformBoxManip: Literal[833]
    kTransformGeometry: Literal[610]
    kTranslateBoxManip: Literal[225]
    kTranslateLimitsManip: Literal[226]
    kTranslateManip: Literal[227]
    kTranslateManip2D: Literal[206]
    kTranslateUVManip: Literal[213]
    kTranslateUVManip2D: Literal[707]
    kTranslationFromMatrix: Literal[1202]
    kTriadManip: Literal[237]
    kTrim: Literal[105]
    kTrimLocator: Literal[287]
    kTrimManip: Literal[228]
    kTrimWithBoundaries: Literal[934]
    kTriplanarProjectionManip: Literal[188]
    kTripleIndexedComponent: Literal[716]
    kTripleShadingSwitch: Literal[621]
    kTrsInsertManip: Literal[203]
    kTrsManip: Literal[189]
    kTrsTransManip: Literal[202]
    kTrsXformManip: Literal[204]
    kTruncate: Literal[1194]
    kTurbulence: Literal[262]
    kTweak: Literal[345]
    kTwoPointArcManip: Literal[651]
    kTxSl: Literal[518]
    kTypedAttribute: Literal[574]
    kUInt64ArrayData: Literal[814]
    kUVManip2D: Literal[706]
    kUVPin: Literal[991]
    kUfeProxyTransform: Literal[1135]
    kUint64SingleIndexedComponent: Literal[1041]
    kUintArrayData: Literal[587]
    kUnderWorld: Literal[109]
    kUniform: Literal[263]
    kUniformFalloff: Literal[1143]
    kUnitAttribute: Literal[573]
    kUnitConversion: Literal[529]
    kUnitToTimeConversion: Literal[530]
    kUnknown: Literal[532]
    kUnknownDag: Literal[316]
    kUnknownTransform: Literal[246]
    kUntrim: Literal[106]
    kUnused1: Literal[844]
    kUnused2: Literal[845]
    kUnused3: Literal[846]
    kUnused4: Literal[847]
    kUnused5: Literal[848]
    kUnused6: Literal[849]
    kUseBackground: Literal[531]
    kUvChooser: Literal[798]
    kVectorArrayData: Literal[608]
    kVectorProduct: Literal[533]
    kVertexBakeSet: Literal[473]
    kVertexWeightSet: Literal[1065]
    kViewColorManager: Literal[672]
    kViewManip: Literal[930]
    kVolumeAxis: Literal[800]
    kVolumeBindManip: Literal[1064]
    kVolumeFog: Literal[871]
    kVolumeLight: Literal[898]
    kVolumeNoise: Literal[877]
    kVolumeShader: Literal[534]
    kVortex: Literal[264]
    kWater: Literal[506]
    kWeightFunctionData: Literal[1148]
    kWeightGeometryFilt: Literal[346]
    kWire: Literal[355]
    kWood: Literal[519]
    kWorld: Literal[247]
    kWrapFilter: Literal[745]
    kWriteToColorBuffer: Literal[1045]
    kWriteToDepthBuffer: Literal[1047]
    kWriteToFrameBuffer: Literal[1044]
    kWriteToLabelBuffer: Literal[1048]
    kWriteToVectorBuffer: Literal[1046]
    kXformManip: Literal[931]
    kXsectionSubdivEdit: Literal[820]
